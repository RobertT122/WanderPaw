/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/littlejsengine/dist/littlejs.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/littlejsengine/dist/littlejs.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASSERT: () => (/* binding */ ASSERT),\n/* harmony export */   Color: () => (/* binding */ Color),\n/* harmony export */   EngineObject: () => (/* binding */ EngineObject),\n/* harmony export */   FontImage: () => (/* binding */ FontImage),\n/* harmony export */   Medal: () => (/* binding */ Medal),\n/* harmony export */   Music: () => (/* binding */ Music),\n/* harmony export */   PI: () => (/* binding */ PI),\n/* harmony export */   Particle: () => (/* binding */ Particle),\n/* harmony export */   ParticleEmitter: () => (/* binding */ ParticleEmitter),\n/* harmony export */   RandomGenerator: () => (/* binding */ RandomGenerator),\n/* harmony export */   Sound: () => (/* binding */ Sound),\n/* harmony export */   SoundWave: () => (/* binding */ SoundWave),\n/* harmony export */   TextureInfo: () => (/* binding */ TextureInfo),\n/* harmony export */   TileInfo: () => (/* binding */ TileInfo),\n/* harmony export */   TileLayer: () => (/* binding */ TileLayer),\n/* harmony export */   TileLayerData: () => (/* binding */ TileLayerData),\n/* harmony export */   Timer: () => (/* binding */ Timer),\n/* harmony export */   Vector2: () => (/* binding */ Vector2),\n/* harmony export */   abs: () => (/* binding */ abs),\n/* harmony export */   audioContext: () => (/* binding */ audioContext),\n/* harmony export */   cameraPos: () => (/* binding */ cameraPos),\n/* harmony export */   cameraScale: () => (/* binding */ cameraScale),\n/* harmony export */   canvasFixedSize: () => (/* binding */ canvasFixedSize),\n/* harmony export */   canvasMaxSize: () => (/* binding */ canvasMaxSize),\n/* harmony export */   canvasPixelated: () => (/* binding */ canvasPixelated),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clearInput: () => (/* binding */ clearInput),\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   debugCircle: () => (/* binding */ debugCircle),\n/* harmony export */   debugClear: () => (/* binding */ debugClear),\n/* harmony export */   debugLine: () => (/* binding */ debugLine),\n/* harmony export */   debugOverlap: () => (/* binding */ debugOverlap),\n/* harmony export */   debugOverlay: () => (/* binding */ debugOverlay),\n/* harmony export */   debugPoint: () => (/* binding */ debugPoint),\n/* harmony export */   debugPoly: () => (/* binding */ debugPoly),\n/* harmony export */   debugRect: () => (/* binding */ debugRect),\n/* harmony export */   debugSaveCanvas: () => (/* binding */ debugSaveCanvas),\n/* harmony export */   debugSaveDataURL: () => (/* binding */ debugSaveDataURL),\n/* harmony export */   debugSaveText: () => (/* binding */ debugSaveText),\n/* harmony export */   debugText: () => (/* binding */ debugText),\n/* harmony export */   distanceAngle: () => (/* binding */ distanceAngle),\n/* harmony export */   distanceWrap: () => (/* binding */ distanceWrap),\n/* harmony export */   drawCanvas2D: () => (/* binding */ drawCanvas2D),\n/* harmony export */   drawLine: () => (/* binding */ drawLine),\n/* harmony export */   drawRect: () => (/* binding */ drawRect),\n/* harmony export */   drawText: () => (/* binding */ drawText),\n/* harmony export */   drawTextScreen: () => (/* binding */ drawTextScreen),\n/* harmony export */   drawTile: () => (/* binding */ drawTile),\n/* harmony export */   enablePhysicsSolver: () => (/* binding */ enablePhysicsSolver),\n/* harmony export */   engineAddPlugin: () => (/* binding */ engineAddPlugin),\n/* harmony export */   engineFontImage: () => (/* binding */ engineFontImage),\n/* harmony export */   engineInit: () => (/* binding */ engineInit),\n/* harmony export */   engineName: () => (/* binding */ engineName),\n/* harmony export */   engineObjects: () => (/* binding */ engineObjects),\n/* harmony export */   engineObjectsCallback: () => (/* binding */ engineObjectsCallback),\n/* harmony export */   engineObjectsDestroy: () => (/* binding */ engineObjectsDestroy),\n/* harmony export */   engineObjectsUpdate: () => (/* binding */ engineObjectsUpdate),\n/* harmony export */   engineVersion: () => (/* binding */ engineVersion),\n/* harmony export */   fontDefault: () => (/* binding */ fontDefault),\n/* harmony export */   formatTime: () => (/* binding */ formatTime),\n/* harmony export */   frame: () => (/* binding */ frame),\n/* harmony export */   frameRate: () => (/* binding */ frameRate),\n/* harmony export */   gamepadDirectionEmulateStick: () => (/* binding */ gamepadDirectionEmulateStick),\n/* harmony export */   gamepadIsDown: () => (/* binding */ gamepadIsDown),\n/* harmony export */   gamepadStick: () => (/* binding */ gamepadStick),\n/* harmony export */   gamepadWasPressed: () => (/* binding */ gamepadWasPressed),\n/* harmony export */   gamepadWasReleased: () => (/* binding */ gamepadWasReleased),\n/* harmony export */   gamepadsEnable: () => (/* binding */ gamepadsEnable),\n/* harmony export */   gamepadsUpdate: () => (/* binding */ gamepadsUpdate),\n/* harmony export */   getCameraSize: () => (/* binding */ getCameraSize),\n/* harmony export */   getNoteFrequency: () => (/* binding */ getNoteFrequency),\n/* harmony export */   getTileCollisionData: () => (/* binding */ getTileCollisionData),\n/* harmony export */   glCanvas: () => (/* binding */ glCanvas),\n/* harmony export */   glCompileShader: () => (/* binding */ glCompileShader),\n/* harmony export */   glContext: () => (/* binding */ glContext),\n/* harmony export */   glCopyToContext: () => (/* binding */ glCopyToContext),\n/* harmony export */   glCreateProgram: () => (/* binding */ glCreateProgram),\n/* harmony export */   glCreateTexture: () => (/* binding */ glCreateTexture),\n/* harmony export */   glDraw: () => (/* binding */ glDraw),\n/* harmony export */   glEnable: () => (/* binding */ glEnable),\n/* harmony export */   glFlush: () => (/* binding */ glFlush),\n/* harmony export */   glOverlay: () => (/* binding */ glOverlay),\n/* harmony export */   glSetTexture: () => (/* binding */ glSetTexture),\n/* harmony export */   gravity: () => (/* binding */ gravity),\n/* harmony export */   headlessMode: () => (/* binding */ headlessMode),\n/* harmony export */   hsl: () => (/* binding */ hsl),\n/* harmony export */   initTileCollision: () => (/* binding */ initTileCollision),\n/* harmony export */   inputWASDEmulateDirection: () => (/* binding */ inputWASDEmulateDirection),\n/* harmony export */   isFullscreen: () => (/* binding */ isFullscreen),\n/* harmony export */   isOverlapping: () => (/* binding */ isOverlapping),\n/* harmony export */   isTouchDevice: () => (/* binding */ isTouchDevice),\n/* harmony export */   isUsingGamepad: () => (/* binding */ isUsingGamepad),\n/* harmony export */   keyIsDown: () => (/* binding */ keyIsDown),\n/* harmony export */   keyWasPressed: () => (/* binding */ keyWasPressed),\n/* harmony export */   keyWasReleased: () => (/* binding */ keyWasReleased),\n/* harmony export */   lerp: () => (/* binding */ lerp),\n/* harmony export */   lerpAngle: () => (/* binding */ lerpAngle),\n/* harmony export */   lerpWrap: () => (/* binding */ lerpWrap),\n/* harmony export */   mainCanvas: () => (/* binding */ mainCanvas),\n/* harmony export */   mainCanvasSize: () => (/* binding */ mainCanvasSize),\n/* harmony export */   mainContext: () => (/* binding */ mainContext),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   medalDisplayIconSize: () => (/* binding */ medalDisplayIconSize),\n/* harmony export */   medalDisplaySize: () => (/* binding */ medalDisplaySize),\n/* harmony export */   medalDisplaySlideTime: () => (/* binding */ medalDisplaySlideTime),\n/* harmony export */   medalDisplayTime: () => (/* binding */ medalDisplayTime),\n/* harmony export */   medals: () => (/* binding */ medals),\n/* harmony export */   medalsInit: () => (/* binding */ medalsInit),\n/* harmony export */   medalsPreventUnlock: () => (/* binding */ medalsPreventUnlock),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   mouseIsDown: () => (/* binding */ mouseIsDown),\n/* harmony export */   mousePos: () => (/* binding */ mousePos),\n/* harmony export */   mousePosScreen: () => (/* binding */ mousePosScreen),\n/* harmony export */   mouseToScreen: () => (/* binding */ mouseToScreen),\n/* harmony export */   mouseWasPressed: () => (/* binding */ mouseWasPressed),\n/* harmony export */   mouseWasReleased: () => (/* binding */ mouseWasReleased),\n/* harmony export */   mouseWheel: () => (/* binding */ mouseWheel),\n/* harmony export */   nearestPowerOfTwo: () => (/* binding */ nearestPowerOfTwo),\n/* harmony export */   objectDefaultAngleDamping: () => (/* binding */ objectDefaultAngleDamping),\n/* harmony export */   objectDefaultDamping: () => (/* binding */ objectDefaultDamping),\n/* harmony export */   objectDefaultElasticity: () => (/* binding */ objectDefaultElasticity),\n/* harmony export */   objectDefaultFriction: () => (/* binding */ objectDefaultFriction),\n/* harmony export */   objectDefaultMass: () => (/* binding */ objectDefaultMass),\n/* harmony export */   objectMaxSpeed: () => (/* binding */ objectMaxSpeed),\n/* harmony export */   overlayCanvas: () => (/* binding */ overlayCanvas),\n/* harmony export */   overlayContext: () => (/* binding */ overlayContext),\n/* harmony export */   particleEmitRateScale: () => (/* binding */ particleEmitRateScale),\n/* harmony export */   paused: () => (/* binding */ paused),\n/* harmony export */   percent: () => (/* binding */ percent),\n/* harmony export */   playAudioFile: () => (/* binding */ playAudioFile),\n/* harmony export */   playSamples: () => (/* binding */ playSamples),\n/* harmony export */   preventDefaultInput: () => (/* binding */ preventDefaultInput),\n/* harmony export */   rand: () => (/* binding */ rand),\n/* harmony export */   randColor: () => (/* binding */ randColor),\n/* harmony export */   randInCircle: () => (/* binding */ randInCircle),\n/* harmony export */   randInt: () => (/* binding */ randInt),\n/* harmony export */   randSign: () => (/* binding */ randSign),\n/* harmony export */   randVector: () => (/* binding */ randVector),\n/* harmony export */   rgb: () => (/* binding */ rgb),\n/* harmony export */   screenToWorld: () => (/* binding */ screenToWorld),\n/* harmony export */   setBlendMode: () => (/* binding */ setBlendMode),\n/* harmony export */   setCameraPos: () => (/* binding */ setCameraPos),\n/* harmony export */   setCameraScale: () => (/* binding */ setCameraScale),\n/* harmony export */   setCanvasFixedSize: () => (/* binding */ setCanvasFixedSize),\n/* harmony export */   setCanvasMaxSize: () => (/* binding */ setCanvasMaxSize),\n/* harmony export */   setCanvasPixelated: () => (/* binding */ setCanvasPixelated),\n/* harmony export */   setDebugKey: () => (/* binding */ setDebugKey),\n/* harmony export */   setEnablePhysicsSolver: () => (/* binding */ setEnablePhysicsSolver),\n/* harmony export */   setFontDefault: () => (/* binding */ setFontDefault),\n/* harmony export */   setGamepadDirectionEmulateStick: () => (/* binding */ setGamepadDirectionEmulateStick),\n/* harmony export */   setGamepadsEnable: () => (/* binding */ setGamepadsEnable),\n/* harmony export */   setGlEnable: () => (/* binding */ setGlEnable),\n/* harmony export */   setGlOverlay: () => (/* binding */ setGlOverlay),\n/* harmony export */   setGravity: () => (/* binding */ setGravity),\n/* harmony export */   setHeadlessMode: () => (/* binding */ setHeadlessMode),\n/* harmony export */   setInputWASDEmulateDirection: () => (/* binding */ setInputWASDEmulateDirection),\n/* harmony export */   setMedalDisplayIconSize: () => (/* binding */ setMedalDisplayIconSize),\n/* harmony export */   setMedalDisplaySize: () => (/* binding */ setMedalDisplaySize),\n/* harmony export */   setMedalDisplaySlideTime: () => (/* binding */ setMedalDisplaySlideTime),\n/* harmony export */   setMedalDisplayTime: () => (/* binding */ setMedalDisplayTime),\n/* harmony export */   setMedalsPreventUnlock: () => (/* binding */ setMedalsPreventUnlock),\n/* harmony export */   setObjectDefaultAngleDamping: () => (/* binding */ setObjectDefaultAngleDamping),\n/* harmony export */   setObjectDefaultDamping: () => (/* binding */ setObjectDefaultDamping),\n/* harmony export */   setObjectDefaultElasticity: () => (/* binding */ setObjectDefaultElasticity),\n/* harmony export */   setObjectDefaultFriction: () => (/* binding */ setObjectDefaultFriction),\n/* harmony export */   setObjectDefaultMass: () => (/* binding */ setObjectDefaultMass),\n/* harmony export */   setObjectMaxSpeed: () => (/* binding */ setObjectMaxSpeed),\n/* harmony export */   setParticleEmitRateScale: () => (/* binding */ setParticleEmitRateScale),\n/* harmony export */   setPaused: () => (/* binding */ setPaused),\n/* harmony export */   setShowSplashScreen: () => (/* binding */ setShowSplashScreen),\n/* harmony export */   setShowWatermark: () => (/* binding */ setShowWatermark),\n/* harmony export */   setSoundDefaultRange: () => (/* binding */ setSoundDefaultRange),\n/* harmony export */   setSoundDefaultTaper: () => (/* binding */ setSoundDefaultTaper),\n/* harmony export */   setSoundEnable: () => (/* binding */ setSoundEnable),\n/* harmony export */   setSoundVolume: () => (/* binding */ setSoundVolume),\n/* harmony export */   setTileCollisionData: () => (/* binding */ setTileCollisionData),\n/* harmony export */   setTileFixBleedScale: () => (/* binding */ setTileFixBleedScale),\n/* harmony export */   setTileSizeDefault: () => (/* binding */ setTileSizeDefault),\n/* harmony export */   setTouchGamepadAlpha: () => (/* binding */ setTouchGamepadAlpha),\n/* harmony export */   setTouchGamepadAnalog: () => (/* binding */ setTouchGamepadAnalog),\n/* harmony export */   setTouchGamepadEnable: () => (/* binding */ setTouchGamepadEnable),\n/* harmony export */   setTouchGamepadSize: () => (/* binding */ setTouchGamepadSize),\n/* harmony export */   setTouchInputEnable: () => (/* binding */ setTouchInputEnable),\n/* harmony export */   setVibrateEnable: () => (/* binding */ setVibrateEnable),\n/* harmony export */   showSplashScreen: () => (/* binding */ showSplashScreen),\n/* harmony export */   showWatermark: () => (/* binding */ showWatermark),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   smoothStep: () => (/* binding */ smoothStep),\n/* harmony export */   soundDefaultRange: () => (/* binding */ soundDefaultRange),\n/* harmony export */   soundDefaultTaper: () => (/* binding */ soundDefaultTaper),\n/* harmony export */   soundEnable: () => (/* binding */ soundEnable),\n/* harmony export */   soundVolume: () => (/* binding */ soundVolume),\n/* harmony export */   speak: () => (/* binding */ speak),\n/* harmony export */   speakStop: () => (/* binding */ speakStop),\n/* harmony export */   textureInfos: () => (/* binding */ textureInfos),\n/* harmony export */   tile: () => (/* binding */ tile),\n/* harmony export */   tileCollision: () => (/* binding */ tileCollision),\n/* harmony export */   tileCollisionRaycast: () => (/* binding */ tileCollisionRaycast),\n/* harmony export */   tileCollisionSize: () => (/* binding */ tileCollisionSize),\n/* harmony export */   tileCollisionTest: () => (/* binding */ tileCollisionTest),\n/* harmony export */   tileFixBleedScale: () => (/* binding */ tileFixBleedScale),\n/* harmony export */   tileSizeDefault: () => (/* binding */ tileSizeDefault),\n/* harmony export */   time: () => (/* binding */ time),\n/* harmony export */   timeDelta: () => (/* binding */ timeDelta),\n/* harmony export */   timeReal: () => (/* binding */ timeReal),\n/* harmony export */   toggleFullscreen: () => (/* binding */ toggleFullscreen),\n/* harmony export */   touchGamepadAlpha: () => (/* binding */ touchGamepadAlpha),\n/* harmony export */   touchGamepadAnalog: () => (/* binding */ touchGamepadAnalog),\n/* harmony export */   touchGamepadEnable: () => (/* binding */ touchGamepadEnable),\n/* harmony export */   touchGamepadSize: () => (/* binding */ touchGamepadSize),\n/* harmony export */   vec2: () => (/* binding */ vec2),\n/* harmony export */   vibrate: () => (/* binding */ vibrate),\n/* harmony export */   vibrateEnable: () => (/* binding */ vibrateEnable),\n/* harmony export */   vibrateStop: () => (/* binding */ vibrateStop),\n/* harmony export */   wave: () => (/* binding */ wave),\n/* harmony export */   worldToScreen: () => (/* binding */ worldToScreen),\n/* harmony export */   zzfx: () => (/* binding */ zzfx)\n/* harmony export */ });\n// LittleJS - MIT License - Copyright 2021 Frank Force\n\n\n\n/** \r\n * LittleJS Debug System\r\n * - Press Esc to show debug overlay with mouse pick\r\n * - Number keys toggle debug functions\r\n * - +/- apply time scale\r\n * - Debug primitive rendering\r\n * - Save a 2d canvas as a png image\r\n * @namespace Debug\r\n */\r\n\r\n\r\n\r\n/** True if debug is enabled\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */\r\nconst debug = true;\r\n\r\n/** True if asserts are enaled\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */\r\nconst enableAsserts = true;\r\n\r\n/** Size to render debug points by default\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Debug */\r\nconst debugPointSize = .5;\r\n\r\n/** True if watermark with FPS should be shown, false in release builds\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */\r\nlet showWatermark = true;\r\n\r\n/** Key code used to toggle debug mode, Esc by default\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Debug */\r\nlet debugKey = 'Escape';\r\n\r\n/** True if the debug overlay is active, always false in release builds\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */\r\nlet debugOverlay = false;\r\n\r\n// Engine internal variables not exposed to documentation\r\nlet debugPrimitives = [], debugPhysics = false, debugRaycast = false, debugParticles = false, debugGamepads = false, debugMedals = false, debugTakeScreenshot, downloadLink;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Debug helper functions\r\n\r\n/** Asserts if the expression is false, does not do anything in release builds\r\n *  @param {Boolean} assert\r\n *  @param {Object} [output]\r\n *  @memberof Debug */\r\nfunction ASSERT(assert, output) \r\n{\r\n    if (enableAsserts)\r\n        output ? console.assert(assert, output) : console.assert(assert);\r\n}\r\n\r\n/** Draw a debug rectangle in world space\r\n *  @param {Vector2} pos\r\n *  @param {Vector2} [size=Vector2()]\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @param {Boolean} [fill]\r\n *  @memberof Debug */\r\nfunction debugRect(pos, size=vec2(), color='#fff', time=0, angle=0, fill=false)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugPrimitives.push({pos, size:vec2(size), color, time:new Timer(time), angle, fill});\r\n}\r\n\r\n/** Draw a debug poly in world space\r\n *  @param {Vector2} pos\r\n *  @param {Array}   points\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @param {Boolean} [fill]\r\n *  @memberof Debug */\r\nfunction debugPoly(pos, points, color='#fff', time=0, angle=0, fill=false)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugPrimitives.push({pos, points, color, time:new Timer(time), angle, fill});\r\n}\r\n\r\n/** Draw a debug circle in world space\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [radius]\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Boolean} [fill]\r\n *  @memberof Debug */\r\nfunction debugCircle(pos, radius=0, color='#fff', time=0, fill=false)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugPrimitives.push({pos, size:radius, color, time:new Timer(time), angle:0, fill});\r\n}\r\n\r\n/** Draw a debug point in world space\r\n *  @param {Vector2} pos\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @memberof Debug */\r\nfunction debugPoint(pos, color, time, angle)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugRect(pos, undefined, color, time, angle);\r\n}\r\n\r\n/** Draw a debug line in world space\r\n *  @param {Vector2} posA\r\n *  @param {Vector2} posB\r\n *  @param {String}  [color]\r\n *  @param {Number}  [thickness]\r\n *  @param {Number}  [time]\r\n *  @memberof Debug */\r\nfunction debugLine(posA, posB, color, thickness=.1, time)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    const halfDelta = vec2((posB.x - posA.x)/2, (posB.y - posA.y)/2);\r\n    const size = vec2(thickness, halfDelta.length()*2);\r\n    debugRect(posA.add(halfDelta), size, color, time, halfDelta.angle(), true);\r\n}\r\n\r\n/** Draw a debug combined axis aligned bounding box in world space\r\n *  @param {Vector2} pA - position A\r\n *  @param {Vector2} sA - size A\r\n *  @param {Vector2} pB - position B\r\n *  @param {Vector2} sB - size B\r\n *  @param {String}  [color]\r\n *  @memberof Debug */\r\nfunction debugOverlap(pA, sA, pB, sB, color)\r\n{\r\n    const minPos = vec2(min(pA.x - sA.x/2, pB.x - sB.x/2), min(pA.y - sA.y/2, pB.y - sB.y/2));\r\n    const maxPos = vec2(max(pA.x + sA.x/2, pB.x + sB.x/2), max(pA.y + sA.y/2, pB.y + sB.y/2));\r\n    debugRect(minPos.lerp(maxPos,.5), maxPos.subtract(minPos), color);\r\n}\r\n\r\n/** Draw a debug axis aligned bounding box in world space\r\n *  @param {String}  text\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [size]\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @param {String}  [font]\r\n *  @memberof Debug */\r\nfunction debugText(text, pos, size=1, color='#fff', time=0, angle=0, font='monospace')\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugPrimitives.push({text, pos, size, color, time:new Timer(time), angle, font});\r\n}\r\n\r\n/** Clear all debug primitives in the list\r\n *  @memberof Debug */\r\nfunction debugClear() { debugPrimitives = []; }\r\n\r\n/** Save a canvas to disk \r\n *  @param {HTMLCanvasElement} canvas\r\n *  @param {String}            [filename]\r\n *  @param {String}            [type]\r\n *  @memberof Debug */\r\nfunction debugSaveCanvas(canvas, filename='screenshot', type='image/png')\r\n{ debugSaveDataURL(canvas.toDataURL(type), filename); }\r\n\r\n/** Save a text file to disk \r\n *  @param {String}     text\r\n *  @param {String}     [filename]\r\n *  @param {String}     [type]\r\n *  @memberof Debug */\r\nfunction debugSaveText(text, filename='text', type='text/plain')\r\n{ debugSaveDataURL(URL.createObjectURL(new Blob([text], {'type':type})), filename); }\r\n\r\n/** Save a data url to disk \r\n *  @param {String}     dataURL\r\n *  @param {String}     filename\r\n *  @memberof Debug */\r\nfunction debugSaveDataURL(dataURL, filename)\r\n{\r\n    downloadLink.download = filename;\r\n    downloadLink.href = dataURL;\r\n    downloadLink.click();\r\n}\r\n\r\n/** Show error as full page of red text\r\n *  @memberof Debug */\r\nfunction debugShowErrors()\r\n{\r\n    onunhandledrejection = (event)=>showError(event.reason);\r\n    onerror = (event, source, lineno, colno)=>\r\n        showError(`${event}\\n${source}\\nLn ${lineno}, Col ${colno}`);\r\n\r\n    const showError = (message)=>\r\n    {\r\n        document.body.style.backgroundColor = '#111';\r\n        document.body.innerHTML = `<pre style=color:#f00;font-size:50px>` + message;\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Engine debug functions (called automatically)\r\n\r\nfunction debugInit()\r\n{\r\n    // create link for saving screenshots\r\n    downloadLink = document.createElement('a');\r\n}\r\n\r\nfunction debugUpdate()\r\n{\r\n    if (!debug)\r\n        return;\r\n\r\n    if (keyWasPressed(debugKey)) // Esc\r\n        debugOverlay = !debugOverlay;\r\n    if (debugOverlay)\r\n    {\r\n        if (keyWasPressed('Digit0'))\r\n            showWatermark = !showWatermark;\r\n        if (keyWasPressed('Digit1'))\r\n            debugPhysics = !debugPhysics, debugParticles = false;\r\n        if (keyWasPressed('Digit2'))\r\n            debugParticles = !debugParticles, debugPhysics = false;\r\n        if (keyWasPressed('Digit3'))\r\n            debugGamepads = !debugGamepads;\r\n        if (keyWasPressed('Digit4'))\r\n            debugRaycast = !debugRaycast;\r\n        if (keyWasPressed('Digit5'))\r\n            debugTakeScreenshot = 1;\r\n    }\r\n}\r\n\r\nfunction debugRender()\r\n{\r\n    glCopyToContext(mainContext);\r\n\r\n    if (debugTakeScreenshot)\r\n    {\r\n        // composite canvas\r\n        glCopyToContext(mainContext, true);\r\n        mainContext.drawImage(overlayCanvas, 0, 0);\r\n        overlayCanvas.width |= 0;\r\n\r\n        // remove alpha and save\r\n        const w = mainCanvas.width, h = mainCanvas.height;\r\n        overlayContext.fillRect(0,0,w,h);\r\n        overlayContext.drawImage(mainCanvas, 0, 0);\r\n        debugSaveCanvas(overlayCanvas);\r\n        debugTakeScreenshot = 0;\r\n    }\r\n\r\n    if (debugGamepads && gamepadsEnable && navigator.getGamepads)\r\n    {\r\n        // gamepad debug display\r\n        const gamepads = navigator.getGamepads();\r\n        for (let i = gamepads.length; i--;)\r\n        {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad)\r\n            {\r\n                const stickScale = 1;\r\n                const buttonScale = .2;\r\n                const centerPos = cameraPos;\r\n                const sticks = gamepadStickData[i];\r\n                for (let j = sticks.length; j--;)\r\n                {\r\n                    const drawPos = centerPos.add(vec2(j*stickScale*2, i*stickScale*3));\r\n                    const stickPos = drawPos.add(sticks[j].scale(stickScale));\r\n                    debugCircle(drawPos, stickScale, '#fff7',0,true);\r\n                    debugLine(drawPos, stickPos, '#f00');\r\n                    debugPoint(stickPos, '#f00');\r\n                }\r\n                for (let j = gamepad.buttons.length; j--;)\r\n                {\r\n                    const drawPos = centerPos.add(vec2(j*buttonScale*2, i*stickScale*3-stickScale-buttonScale));\r\n                    const pressed = gamepad.buttons[j].pressed;\r\n                    debugCircle(drawPos, buttonScale, pressed ? '#f00' : '#fff7', 0, true);\r\n                    debugText(''+j, drawPos, .2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let debugObject;\r\n    if (debugOverlay)\r\n    {\r\n        const saveContext = mainContext;\r\n        mainContext = overlayContext;\r\n        \r\n        // draw red rectangle around screen\r\n        const cameraSize = getCameraSize();\r\n        debugRect(cameraPos, cameraSize.subtract(vec2(.1)), '#f008');\r\n\r\n        // mouse pick\r\n        let bestDistance = Infinity;\r\n        for (const o of engineObjects)\r\n        {\r\n            if (o.canvas || o.destroyed)\r\n                continue;\r\n\r\n            o.renderDebugInfo();\r\n            if (!o.size.x || !o.size.y)\r\n                continue;\r\n\r\n            const distance = mousePos.distanceSquared(o.pos);\r\n            if (distance < bestDistance)\r\n            {\r\n                bestDistance = distance;\r\n                debugObject = o;\r\n            }\r\n        }\r\n\r\n        if (tileCollisionSize.x > 0 && tileCollisionSize.y > 0)\r\n            drawRect(mousePos.floor().add(vec2(.5)), vec2(1), rgb(0,0,1,.5), 0, false);\r\n        mainContext = saveContext;\r\n\r\n        //glCopyToContext(mainContext = saveContext);\r\n    }\r\n\r\n    {\r\n        // draw debug primitives\r\n        overlayContext.lineWidth = 2;\r\n        const pointSize = debugPointSize * cameraScale;\r\n        debugPrimitives.forEach(p=>\r\n        {\r\n            overlayContext.save();\r\n\r\n            // create canvas transform from world space to screen space\r\n            const pos = worldToScreen(p.pos);\r\n            overlayContext.translate(pos.x|0, pos.y|0);\r\n            overlayContext.rotate(p.angle);\r\n            overlayContext.scale(1, p.text ? 1 : -1);\r\n            overlayContext.fillStyle = overlayContext.strokeStyle = p.color;\r\n\r\n            if (p.text != undefined)\r\n            {\r\n                overlayContext.font = p.size*cameraScale + 'px '+ p.font;\r\n                overlayContext.textAlign = 'center';\r\n                overlayContext.textBaseline = 'middle';\r\n                overlayContext.fillText(p.text, 0, 0);\r\n            }\r\n            else if (p.points != undefined)\r\n            {\r\n                // poly\r\n                overlayContext.beginPath();\r\n                for (const point of p.points)\r\n                {\r\n                    const p2 = point.scale(cameraScale).floor();\r\n                    overlayContext.lineTo(p2.x, p2.y);\r\n                }\r\n                overlayContext.closePath();\r\n                p.fill && overlayContext.fill();\r\n                overlayContext.stroke();\r\n            }\r\n            else if (p.size == 0 || p.size.x === 0 && p.size.y === 0)\r\n            {\r\n                // point\r\n                overlayContext.fillRect(-pointSize/2, -1, pointSize, 3);\r\n                overlayContext.fillRect(-1, -pointSize/2, 3, pointSize);\r\n            }\r\n            else if (p.size.x != undefined)\r\n            {\r\n                // rect\r\n                const s = p.size.scale(cameraScale).floor();\r\n                const w = s.x, h = s.y;\r\n                p.fill && overlayContext.fillRect(-w/2|0, -h/2|0, w, h);\r\n                overlayContext.strokeRect(-w/2|0, -h/2|0, w, h);\r\n            }\r\n            else\r\n            {\r\n                // circle\r\n                overlayContext.beginPath();\r\n                overlayContext.arc(0, 0, p.size*cameraScale, 0, 9);\r\n                p.fill && overlayContext.fill();\r\n                overlayContext.stroke();\r\n            }\r\n            \r\n            overlayContext.restore();\r\n        });\r\n\r\n        // remove expired primitives\r\n        debugPrimitives = debugPrimitives.filter(r=>r.time<0);\r\n    }\r\n    \r\n    if (debugObject)\r\n    {\r\n        const saveContext = mainContext;\r\n        mainContext = overlayContext;\r\n        const raycastHitPos = tileCollisionRaycast(debugObject.pos, mousePos);\r\n        raycastHitPos && drawRect(raycastHitPos.floor().add(vec2(.5)), vec2(1), rgb(0,1,1,.3));\r\n        drawLine(mousePos, debugObject.pos, .1, raycastHitPos ? rgb(1,0,0,.5) : rgb(0,1,0,.5), false);\r\n\r\n        const debugText = 'mouse pos = ' + mousePos + \r\n            '\\nmouse collision = ' + getTileCollisionData(mousePos) + \r\n            '\\n\\n--- object info ---\\n' +\r\n            debugObject.toString();\r\n        drawTextScreen(debugText, mousePosScreen, 24, rgb(), .05, undefined, 'center', 'monospace');\r\n        mainContext = saveContext;\r\n    }\r\n\r\n    {\r\n        // draw debug overlay\r\n        overlayContext.save();\r\n        overlayContext.fillStyle = '#fff';\r\n        overlayContext.textAlign = 'left';\r\n        overlayContext.textBaseline = 'top';\r\n        overlayContext.font = '28px monospace';\r\n        overlayContext.shadowColor = '#000';\r\n        overlayContext.shadowBlur = 9;\r\n\r\n        let x = 9, y = -20, h = 30;\r\n        if (debugOverlay)\r\n        {\r\n            overlayContext.fillText(engineName, x, y += h);\r\n            overlayContext.fillText('Objects: ' + engineObjects.length, x, y += h);\r\n            overlayContext.fillText('Time: ' + formatTime(time), x, y += h);\r\n            overlayContext.fillText('---------', x, y += h);\r\n            overlayContext.fillStyle = '#f00';\r\n            overlayContext.fillText('ESC: Debug Overlay', x, y += h);\r\n            overlayContext.fillStyle = debugPhysics ? '#f00' : '#fff';\r\n            overlayContext.fillText('1: Debug Physics', x, y += h);\r\n            overlayContext.fillStyle = debugParticles ? '#f00' : '#fff';\r\n            overlayContext.fillText('2: Debug Particles', x, y += h);\r\n            overlayContext.fillStyle = debugGamepads ? '#f00' : '#fff';\r\n            overlayContext.fillText('3: Debug Gamepads', x, y += h);\r\n            overlayContext.fillStyle = debugRaycast ? '#f00' : '#fff';\r\n            overlayContext.fillText('4: Debug Raycasts', x, y += h);\r\n            overlayContext.fillStyle = '#fff';\r\n            overlayContext.fillText('5: Save Screenshot', x, y += h);\r\n\r\n            let keysPressed = '';\r\n            for(const i in inputData[0])\r\n            {\r\n                if (keyIsDown(i, 0))\r\n                    keysPressed += i + ' ' ;\r\n            }\r\n            keysPressed && overlayContext.fillText('Keys Down: ' + keysPressed, x, y += h);\r\n\r\n            let buttonsPressed = '';\r\n            if (inputData[1])\r\n            for(const i in inputData[1])\r\n            {\r\n                if (keyIsDown(i, 1))\r\n                    buttonsPressed += i + ' ' ;\r\n            }\r\n            buttonsPressed && overlayContext.fillText('Gamepad: ' + buttonsPressed, x, y += h);\r\n        }\r\n        else\r\n        {\r\n            overlayContext.fillText(debugPhysics ? 'Debug Physics' : '', x, y += h);\r\n            overlayContext.fillText(debugParticles ? 'Debug Particles' : '', x, y += h);\r\n            overlayContext.fillText(debugRaycast ? 'Debug Raycasts' : '', x, y += h);\r\n            overlayContext.fillText(debugGamepads ? 'Debug Gamepads' : '', x, y += h);\r\n        }\r\n    \r\n        overlayContext.restore();\r\n    }\r\n}\n/**\r\n * LittleJS Utility Classes and Functions\r\n * - General purpose math library\r\n * - Vector2 - fast, simple, easy 2D vector class\r\n * - Color - holds a rgba color with some math functions\r\n * - Timer - tracks time automatically\r\n * - RandomGenerator - seeded random number generator\r\n * @namespace Utilities\r\n */\r\n\r\n\r\n\r\n/** A shortcut to get Math.PI\r\n *  @type {Number}\r\n *  @default Math.PI\r\n *  @memberof Utilities */\r\nconst PI = Math.PI;\r\n\r\n/** Returns absoulte value of value passed in\r\n *  @param {Number} value\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction abs(value) { return Math.abs(value); }\r\n\r\n/** Returns lowest of two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction min(valueA, valueB) { return Math.min(valueA, valueB); }\r\n\r\n/** Returns highest of two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction max(valueA, valueB) { return Math.max(valueA, valueB); }\r\n\r\n/** Returns the sign of value passed in\r\n *  @param {Number} value\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction sign(value) { return Math.sign(value); }\r\n\r\n/** Returns first parm modulo the second param, but adjusted so negative numbers work as expected\r\n *  @param {Number} dividend\r\n *  @param {Number} [divisor]\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction mod(dividend, divisor=1) { return ((dividend % divisor) + divisor) % divisor; }\r\n\r\n/** Clamps the value beween max and min\r\n *  @param {Number} value\r\n *  @param {Number} [min]\r\n *  @param {Number} [max]\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction clamp(value, min=0, max=1) { return value < min ? min : value > max ? max : value; }\r\n\r\n/** Returns what percentage the value is between valueA and valueB\r\n *  @param {Number} value\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction percent(value, valueA, valueB)\r\n{ return (valueB-=valueA) ? clamp((value-valueA)/valueB) : 0; }\r\n\r\n/** Linearly interpolates between values passed in using percent\r\n *  @param {Number} percent\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction lerp(percent, valueA, valueB) { return valueA + clamp(percent) * (valueB-valueA); }\r\n\r\n/** Returns signed wrapped distance between the two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @param {Number} [wrapSize]\r\n *  @returns {Number}\r\n *  @memberof Utilities */\r\nfunction distanceWrap(valueA, valueB, wrapSize=1)\r\n{ const d = (valueA - valueB) % wrapSize; return d*2 % wrapSize - d; }\r\n\r\n/** Linearly interpolates between values passed in with wrapping\r\n *  @param {Number} percent\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @param {Number} [wrapSize]\r\n *  @returns {Number}\r\n *  @memberof Utilities */\r\nfunction lerpWrap(percent, valueA, valueB, wrapSize=1)\r\n{ return valueB + clamp(percent) * distanceWrap(valueA, valueB, wrapSize); }\r\n\r\n/** Returns signed wrapped distance between the two angles passed in\r\n *  @param {Number} angleA\r\n *  @param {Number} angleB\r\n *  @returns {Number}\r\n *  @memberof Utilities */\r\nfunction distanceAngle(angleA, angleB) { return distanceWrap(angleA, angleB, 2*PI); }\r\n\r\n/** Linearly interpolates between the angles passed in with wrapping\r\n *  @param {Number} percent\r\n *  @param {Number} angleA\r\n *  @param {Number} angleB\r\n *  @returns {Number}\r\n *  @memberof Utilities */\r\nfunction lerpAngle(percent, angleA, angleB) { return lerpWrap(percent, angleA, angleB, 2*PI); }\r\n\r\n/** Applies smoothstep function to the percentage value\r\n *  @param {Number} percent\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction smoothStep(percent) { return percent * percent * (3 - 2 * percent); }\r\n\r\n/** Returns the nearest power of two not less then the value\r\n *  @param {Number} value\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction nearestPowerOfTwo(value) { return 2**Math.ceil(Math.log2(value)); }\r\n\r\n/** Returns true if two axis aligned bounding boxes are overlapping \r\n *  @param {Vector2} posA          - Center of box A\r\n *  @param {Vector2} sizeA         - Size of box A\r\n *  @param {Vector2} posB          - Center of box B\r\n *  @param {Vector2} [sizeB=(0,0)] - Size of box B, a point if undefined\r\n *  @return {Boolean}              - True if overlapping\r\n *  @memberof Utilities */\r\nfunction isOverlapping(posA, sizeA, posB, sizeB=vec2())\r\n{ \r\n    return abs(posA.x - posB.x)*2 < sizeA.x + sizeB.x \r\n        && abs(posA.y - posB.y)*2 < sizeA.y + sizeB.y;\r\n}\r\n\r\n/** Returns true if a line segment is intersecting an axis aligned box\r\n *  @param {Vector2} start - Start of raycast\r\n *  @param {Vector2} end   - End of raycast\r\n *  @param {Vector2} pos   - Center of box\r\n *  @param {Vector2} size  - Size of box\r\n *  @return {Boolean}      - True if intersecting\r\n *  @memberof Utilities */\r\nfunction isIntersecting(start, end, pos, size)\r\n{\r\n    // Liang-Barsky algorithm\r\n    const boxMin = pos.subtract(size.scale(.5));\r\n    const boxMax = boxMin.add(size);\r\n    const delta = end.subtract(start);\r\n    const a = start.subtract(boxMin);\r\n    const b = start.subtract(boxMax);\r\n    const p = [-delta.x, delta.x, -delta.y, delta.y];\r\n    const q = [a.x, -b.x, a.y, -b.y];\r\n    let tMin = 0, tMax = 1;\r\n    for (let i = 4; i--;)\r\n    {\r\n        if (p[i])\r\n        {\r\n            const t = q[i] / p[i];\r\n            if (p[i] < 0)\r\n            {\r\n                if (t > tMax) return false;\r\n                tMin = max(t, tMin);\r\n            }\r\n            else\r\n            {\r\n                if (t < tMin) return false;\r\n                tMax = min(t, tMax);\r\n            }\r\n        }\r\n        else if (q[i] < 0)\r\n            return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/** Returns an oscillating wave between 0 and amplitude with frequency of 1 Hz by default\r\n *  @param {Number} [frequency] - Frequency of the wave in Hz\r\n *  @param {Number} [amplitude] - Amplitude (max height) of the wave\r\n *  @param {Number} [t=time]    - Value to use for time of the wave\r\n *  @return {Number}            - Value waving between 0 and amplitude\r\n *  @memberof Utilities */\r\nfunction wave(frequency=1, amplitude=1, t=time)\r\n{ return amplitude/2 * (1 - Math.cos(t*frequency*2*PI)); }\r\n\r\n/** Formats seconds to mm:ss style for display purposes \r\n *  @param {Number} t - time in seconds\r\n *  @return {String}\r\n *  @memberof Utilities */\r\nfunction formatTime(t) { return (t/60|0) + ':' + (t%60<10?'0':'') + (t%60|0); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Random global functions\r\n *  @namespace Random */\r\n\r\n/** Returns a random value between the two values passed in\r\n *  @param {Number} [valueA]\r\n *  @param {Number} [valueB]\r\n *  @return {Number}\r\n *  @memberof Random */\r\nfunction rand(valueA=1, valueB=0) { return valueB + Math.random() * (valueA-valueB); }\r\n\r\n/** Returns a floored random value the two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} [valueB]\r\n *  @return {Number}\r\n *  @memberof Random */\r\nfunction randInt(valueA, valueB=0) { return Math.floor(rand(valueA,valueB)); }\r\n\r\n/** Randomly returns either -1 or 1\r\n *  @return {Number}\r\n *  @memberof Random */\r\nfunction randSign() { return randInt(2) * 2 - 1; }\r\n\r\n/** Returns a random Vector2 with the passed in length\r\n *  @param {Number} [length]\r\n *  @return {Vector2}\r\n *  @memberof Random */\r\nfunction randVector(length=1) { return new Vector2().setAngle(rand(2*PI), length); }\r\n\r\n/** Returns a random Vector2 within a circular shape\r\n *  @param {Number} [radius]\r\n *  @param {Number} [minRadius]\r\n *  @return {Vector2}\r\n *  @memberof Random */\r\nfunction randInCircle(radius=1, minRadius=0)\r\n{ return radius > 0 ? randVector(radius * rand(minRadius / radius, 1)**.5) : new Vector2; }\r\n\r\n/** Returns a random color between the two passed in colors, combine components if linear\r\n *  @param {Color}   [colorA=(1,1,1,1)]\r\n *  @param {Color}   [colorB=(0,0,0,1)]\r\n *  @param {Boolean} [linear]\r\n *  @return {Color}\r\n *  @memberof Random */\r\nfunction randColor(colorA=new Color, colorB=new Color(0,0,0,1), linear=false)\r\n{\r\n    return linear ? colorA.lerp(colorB, rand()) : \r\n        new Color(rand(colorA.r,colorB.r), rand(colorA.g,colorB.g), rand(colorA.b,colorB.b), rand(colorA.a,colorB.a));\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Seeded random number generator\r\n * - Can be used to create a deterministic random number sequence\r\n * @example\r\n * let r = new RandomGenerator(123); // random number generator with seed 123\r\n * let a = r.float();                // random value between 0 and 1\r\n * let b = r.int(10);                // random integer between 0 and 9\r\n * r.seed = 123;                     // reset the seed\r\n * let c = r.float();                // the same value as a\r\n */\r\nclass RandomGenerator\r\n{\r\n    /** Create a random number generator with the seed passed in\r\n     *  @param {Number} seed - Starting seed */\r\n    constructor(seed)\r\n    {\r\n        /** @property {Number} - random seed */\r\n        this.seed = seed;\r\n    }\r\n\r\n    /** Returns a seeded random value between the two values passed in\r\n    *  @param {Number} [valueA]\r\n    *  @param {Number} [valueB]\r\n    *  @return {Number} */\r\n    float(valueA=1, valueB=0)\r\n    {\r\n        // xorshift algorithm\r\n        this.seed ^= this.seed << 13; \r\n        this.seed ^= this.seed >>> 17; \r\n        this.seed ^= this.seed << 5;\r\n        return valueB + (valueA - valueB) * abs(this.seed % 1e8) / 1e8;\r\n    }\r\n\r\n    /** Returns a floored seeded random value the two values passed in\r\n    *  @param {Number} valueA\r\n    *  @param {Number} [valueB]\r\n    *  @return {Number} */\r\n    int(valueA, valueB=0) { return Math.floor(this.float(valueA, valueB)); }\r\n\r\n    /** Randomly returns either -1 or 1 deterministically\r\n    *  @return {Number} */\r\n    sign() { return this.float() > .5 ? 1 : -1; }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Create a 2d vector, can take another Vector2 to copy, 2 scalars, or 1 scalar\r\n * @param {(Number|Vector2)} [x]\r\n * @param {Number} [y]\r\n * @return {Vector2}\r\n * @example\r\n * let a = vec2(0, 1); // vector with coordinates (0, 1)\r\n * let b = vec2(a);    // copy a into b\r\n * a = vec2(5);        // set a to (5, 5)\r\n * b = vec2();         // set b to (0, 0)\r\n * @memberof Utilities\r\n */\r\nfunction vec2(x=0, y)\r\n{\r\n    return typeof x == 'number' ? \r\n        new Vector2(x, y == undefined? x : y) : \r\n        new Vector2(x.x, x.y);\r\n}\r\n\r\n/** \r\n * Check if object is a valid Vector2\r\n * @param {any} v\r\n * @return {Boolean}\r\n * @memberof Utilities\r\n */\r\nfunction isVector2(v) { return v instanceof Vector2; }\r\n\r\n/** \r\n * 2D Vector object with vector math library\r\n * - Functions do not change this so they can be chained together\r\n * @example\r\n * let a = new Vector2(2, 3); // vector with coordinates (2, 3)\r\n * let b = new Vector2;       // vector with coordinates (0, 0)\r\n * let c = vec2(4, 2);        // use the vec2 function to make a Vector2\r\n * let d = a.add(b).scale(5); // operators can be chained\r\n */\r\nclass Vector2\r\n{\r\n    /** Create a 2D vector with the x and y passed in, can also be created with vec2()\r\n     *  @param {Number} [x] - X axis location\r\n     *  @param {Number} [y] - Y axis location */\r\n    constructor(x=0, y=0)\r\n    {\r\n        ASSERT(typeof x == 'number' && typeof y == 'number');\r\n        /** @property {Number} - X axis location */\r\n        this.x = x;\r\n        /** @property {Number} - Y axis location */\r\n        this.y = y;\r\n    }\r\n\r\n    /** Sets values of this vector and returns self\r\n     *  @param {Number} [x] - X axis location\r\n     *  @param {Number} [y] - Y axis location\r\n     *  @return {Vector2} */\r\n    set(x=0, y=0) { this.x=x; this.y=y; return this; }\r\n\r\n    /** Returns a new vector that is a copy of this\r\n     *  @return {Vector2} */\r\n    copy() { return new Vector2(this.x, this.y); }\r\n\r\n    /** Returns a copy of this vector plus the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */\r\n    add(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return new Vector2(this.x + v.x, this.y + v.y);\r\n    }\r\n\r\n    /** Returns a copy of this vector minus the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */\r\n    subtract(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return new Vector2(this.x - v.x, this.y - v.y);\r\n    }\r\n\r\n    /** Returns a copy of this vector times the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */\r\n    multiply(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return new Vector2(this.x * v.x, this.y * v.y);\r\n    }\r\n\r\n    /** Returns a copy of this vector divided by the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */\r\n    divide(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return new Vector2(this.x / v.x, this.y / v.y);\r\n    }\r\n\r\n    /** Returns a copy of this vector scaled by the vector passed in\r\n     *  @param {Number} s - scale\r\n     *  @return {Vector2} */\r\n    scale(s)\r\n    {\r\n        ASSERT(!isVector2(s));\r\n        return new Vector2(this.x * s, this.y * s);\r\n    }\r\n\r\n    /** Returns the length of this vector\r\n     * @return {Number} */\r\n    length() { return this.lengthSquared()**.5; }\r\n\r\n    /** Returns the length of this vector squared\r\n     * @return {Number} */\r\n    lengthSquared() { return this.x**2 + this.y**2; }\r\n\r\n    /** Returns the distance from this vector to vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */\r\n    distance(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return this.distanceSquared(v)**.5;\r\n    }\r\n\r\n    /** Returns the distance squared from this vector to vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */\r\n    distanceSquared(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return (this.x - v.x)**2 + (this.y - v.y)**2;\r\n    }\r\n\r\n    /** Returns a new vector in same direction as this one with the length passed in\r\n     * @param {Number} [length]\r\n     * @return {Vector2} */\r\n    normalize(length=1)\r\n    {\r\n        const l = this.length();\r\n        return l ? this.scale(length/l) : new Vector2(0, length);\r\n    }\r\n\r\n    /** Returns a new vector clamped to length passed in\r\n     * @param {Number} [length]\r\n     * @return {Vector2} */\r\n    clampLength(length=1)\r\n    {\r\n        const l = this.length();\r\n        return l > length ? this.scale(length/l) : this;\r\n    }\r\n\r\n    /** Returns the dot product of this and the vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */\r\n    dot(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return this.x*v.x + this.y*v.y;\r\n    }\r\n\r\n    /** Returns the cross product of this and the vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */\r\n    cross(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return this.x*v.y - this.y*v.x;\r\n    }\r\n\r\n    /** Returns the angle of this vector, up is angle 0\r\n     * @return {Number} */\r\n    angle() { return Math.atan2(this.x, this.y); }\r\n\r\n    /** Sets this vector with angle and length passed in\r\n     * @param {Number} [angle]\r\n     * @param {Number} [length]\r\n     * @return {Vector2} */\r\n    setAngle(angle=0, length=1) \r\n    {\r\n        this.x = length*Math.sin(angle);\r\n        this.y = length*Math.cos(angle);\r\n        return this;\r\n    }\r\n\r\n    /** Returns copy of this vector rotated by the angle passed in\r\n     * @param {Number} angle\r\n     * @return {Vector2} */\r\n    rotate(angle)\r\n    { \r\n        const c = Math.cos(angle), s = Math.sin(angle); \r\n        return new Vector2(this.x*c - this.y*s, this.x*s + this.y*c);\r\n    }\r\n\r\n    /** Set the integer direction of this vector, corrosponding to multiples of 90 degree rotation (0-3)\r\n     * @param {Number} [direction]\r\n     * @param {Number} [length] */\r\n    setDirection(direction, length=1)\r\n    {\r\n        ASSERT(direction==0 || direction==1 || direction==2 || direction==3);\r\n        return vec2(direction%2 ? direction-1 ? -length : length : 0, \r\n            direction%2 ? 0 : direction ? -length : length);\r\n    }\r\n\r\n    /** Returns the integer direction of this vector, corrosponding to multiples of 90 degree rotation (0-3)\r\n     * @return {Number} */\r\n    direction()\r\n    { return abs(this.x) > abs(this.y) ? this.x < 0 ? 3 : 1 : this.y < 0 ? 2 : 0; }\r\n\r\n    /** Returns a copy of this vector that has been inverted\r\n     * @return {Vector2} */\r\n    invert() { return new Vector2(this.y, -this.x); }\r\n\r\n    /** Returns a copy of this vector with each axis floored\r\n     * @return {Vector2} */\r\n    floor() { return new Vector2(Math.floor(this.x), Math.floor(this.y)); }\r\n\r\n    /** Returns the area this vector covers as a rectangle\r\n     * @return {Number} */\r\n    area() { return abs(this.x * this.y); }\r\n\r\n    /** Returns a new vector that is p percent between this and the vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @param {Number}  percent\r\n     * @return {Vector2} */\r\n    lerp(v, percent)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return this.add(v.subtract(this).scale(clamp(percent)));\r\n    }\r\n\r\n    /** Returns true if this vector is within the bounds of an array size passed in\r\n     * @param {Vector2} arraySize\r\n     * @return {Boolean} */\r\n    arrayCheck(arraySize)\r\n    {\r\n        ASSERT(isVector2(arraySize));\r\n        return this.x >= 0 && this.y >= 0 && this.x < arraySize.x && this.y < arraySize.y;\r\n    }\r\n\r\n    /** Returns this vector expressed as a string\r\n     * @param {Number} digits - precision to display\r\n     * @return {String} */\r\n    toString(digits=3) \r\n    {\r\n        if (debug)\r\n            return `(${(this.x<0?'':' ') + this.x.toFixed(digits)},${(this.y<0?'':' ') + this.y.toFixed(digits)} )`;\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Create a color object with RGBA values, white by default\r\n * @param {Number} [r=1] - red\r\n * @param {Number} [g=1] - green\r\n * @param {Number} [b=1] - blue\r\n * @param {Number} [a=1] - alpha\r\n * @return {Color}\r\n * @memberof Utilities\r\n */\r\nfunction rgb(r, g, b, a) { return new Color(r, g, b, a); }\r\n\r\n/** \r\n * Create a color object with HSLA values, white by default\r\n * @param {Number} [h=0] - hue\r\n * @param {Number} [s=0] - saturation\r\n * @param {Number} [l=1] - lightness\r\n * @param {Number} [a=1] - alpha\r\n * @return {Color}\r\n * @memberof Utilities\r\n */\r\nfunction hsl(h, s, l, a) { return new Color().setHSLA(h, s, l, a); }\r\n\r\n/** \r\n * Check if object is a valid Color\r\n * @param {any} c\r\n * @return {Boolean}\r\n * @memberof Utilities\r\n */\r\nfunction isColor(c) { return c instanceof Color; }\r\n\r\n/** \r\n * Color object (red, green, blue, alpha) with some helpful functions\r\n * @example\r\n * let a = new Color;              // white\r\n * let b = new Color(1, 0, 0);     // red\r\n * let c = new Color(0, 0, 0, 0);  // transparent black\r\n * let d = rgb(0, 0, 1);           // blue using rgb color\r\n * let e = hsl(.3, 1, .5);         // green using hsl color\r\n */\r\nclass Color\r\n{\r\n    /** Create a color with the rgba components passed in, white by default\r\n     *  @param {Number} [r] - red\r\n     *  @param {Number} [g] - green\r\n     *  @param {Number} [b] - blue\r\n     *  @param {Number} [a] - alpha*/\r\n    constructor(r=1, g=1, b=1, a=1)\r\n    {\r\n        /** @property {Number} - Red */\r\n        this.r = r;\r\n        /** @property {Number} - Green */\r\n        this.g = g;\r\n        /** @property {Number} - Blue */\r\n        this.b = b;\r\n        /** @property {Number} - Alpha */\r\n        this.a = a;\r\n    }\r\n\r\n    /** Sets values of this color and returns self\r\n     *  @param {Number} [r] - red\r\n     *  @param {Number} [g] - green\r\n     *  @param {Number} [b] - blue\r\n     *  @param {Number} [a] - alpha\r\n     *  @return {Color} */\r\n    set(r=1, g=1, b=1, a=1)\r\n    { this.r=r; this.g=g; this.b=b; this.a=a; return this; }\r\n\r\n    /** Returns a new color that is a copy of this\r\n     * @return {Color} */\r\n    copy() { return new Color(this.r, this.g, this.b, this.a); }\r\n\r\n    /** Returns a copy of this color plus the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */\r\n    add(c)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return new Color(this.r+c.r, this.g+c.g, this.b+c.b, this.a+c.a);\r\n    }\r\n\r\n    /** Returns a copy of this color minus the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */\r\n    subtract(c)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return new Color(this.r-c.r, this.g-c.g, this.b-c.b, this.a-c.a);\r\n    }\r\n\r\n    /** Returns a copy of this color times the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */\r\n    multiply(c)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return new Color(this.r*c.r, this.g*c.g, this.b*c.b, this.a*c.a);\r\n    }\r\n\r\n    /** Returns a copy of this color divided by the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */\r\n    divide(c)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return new Color(this.r/c.r, this.g/c.g, this.b/c.b, this.a/c.a);\r\n    }\r\n\r\n    /** Returns a copy of this color scaled by the value passed in, alpha can be scaled separately\r\n     * @param {Number} scale\r\n     * @param {Number} [alphaScale=scale]\r\n     * @return {Color} */\r\n    scale(scale, alphaScale=scale) \r\n    { return new Color(this.r*scale, this.g*scale, this.b*scale, this.a*alphaScale); }\r\n\r\n    /** Returns a copy of this color clamped to the valid range between 0 and 1\r\n     * @return {Color} */\r\n    clamp() { return new Color(clamp(this.r), clamp(this.g), clamp(this.b), clamp(this.a)); }\r\n\r\n    /** Returns a new color that is p percent between this and the color passed in\r\n     * @param {Color}  c - other color\r\n     * @param {Number} percent\r\n     * @return {Color} */\r\n    lerp(c, percent)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return this.add(c.subtract(this).scale(clamp(percent)));\r\n    }\r\n\r\n    /** Sets this color given a hue, saturation, lightness, and alpha\r\n     * @param {Number} [h] - hue\r\n     * @param {Number} [s] - saturation\r\n     * @param {Number} [l] - lightness\r\n     * @param {Number} [a] - alpha\r\n     * @return {Color} */\r\n    setHSLA(h=0, s=0, l=1, a=1)\r\n    {\r\n        h = mod(h,1);\r\n        s = clamp(s);\r\n        l = clamp(l);\r\n        const q = l < .5 ? l*(1+s) : l+s-l*s, p = 2*l-q,\r\n            f = (p, q, t)=>\r\n                (t = mod(t,1))*6 < 1 ? p+(q-p)*6*t :\r\n                t*2 < 1 ? q :\r\n                t*3 < 2 ? p+(q-p)*(4-t*6) : p;\r\n        this.r = f(p, q, h + 1/3);\r\n        this.g = f(p, q, h);\r\n        this.b = f(p, q, h - 1/3);\r\n        this.a = a;\r\n        return this;\r\n    }\r\n\r\n    /** Returns this color expressed in hsla format\r\n     * @return {Array} */\r\n    HSLA()\r\n    {\r\n        const r = clamp(this.r);\r\n        const g = clamp(this.g);\r\n        const b = clamp(this.b);\r\n        const a = clamp(this.a);\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        const l = (max + min) / 2;\r\n        \r\n        let h = 0, s = 0;\r\n        if (max != min)\r\n        {\r\n            let d = max - min;\r\n            s = l > .5 ? d / (2 - max - min) : d / (max + min);\r\n            if (r == max)\r\n                h = (g - b) / d + (g < b ? 6 : 0);\r\n            else if (g == max)\r\n                h = (b - r) / d + 2;\r\n            else if (b == max)\r\n                h =  (r - g) / d + 4;\r\n        }\r\n\r\n        return [h / 6, s, l, a];\r\n    }\r\n\r\n    /** Returns a new color that has each component randomly adjusted\r\n     * @param {Number} [amount]\r\n     * @param {Number} [alphaAmount]\r\n     * @return {Color} */\r\n    mutate(amount=.05, alphaAmount=0) \r\n    {\r\n        return new Color\r\n        (\r\n            this.r + rand(amount, -amount),\r\n            this.g + rand(amount, -amount),\r\n            this.b + rand(amount, -amount),\r\n            this.a + rand(alphaAmount, -alphaAmount)\r\n        ).clamp();\r\n    }\r\n\r\n    /** Returns this color expressed as a hex color code\r\n     * @param {Boolean} [useAlpha] - if alpha should be included in result\r\n     * @return {String} */\r\n    toString(useAlpha = true)      \r\n    { \r\n        const toHex = (c)=> ((c=c*255|0)<16 ? '0' : '') + c.toString(16);\r\n        return '#' + toHex(this.r) + toHex(this.g) + toHex(this.b) + (useAlpha ? toHex(this.a) : '');\r\n    }\r\n    \r\n    /** Set this color from a hex code\r\n     * @param {String} hex - html hex code\r\n     * @return {Color} */\r\n    setHex(hex)\r\n    {\r\n        const fromHex = (c)=> clamp(parseInt(hex.slice(c,c+2),16)/255);\r\n        this.r = fromHex(1);\r\n        this.g = fromHex(3),\r\n        this.b = fromHex(5);\r\n        this.a = hex.length > 7 ? fromHex(7) : 1;\r\n        return this;\r\n    }\r\n    \r\n    /** Returns this color expressed as 32 bit RGBA value\r\n     * @return {Number} */\r\n    rgbaInt()  \r\n    {\r\n        const r = clamp(this.r)*255|0;\r\n        const g = clamp(this.g)*255<<8;\r\n        const b = clamp(this.b)*255<<16;\r\n        const a = clamp(this.a)*255<<24;\r\n        return r + g + b + a;\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// default colors\r\n\r\n/** Color - White\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst WHITE = rgb();\r\n\r\n/** Color - Black\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst BLACK = rgb(0,0,0);\r\n\r\n/** Color - Gray\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst GRAY = rgb(.5,.5,.5);\r\n\r\n/** Color - Red\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst RED = rgb(1,0,0);\r\n\r\n/** Color - Orange\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst ORANGE = rgb(1,.5,0);\r\n\r\n/** Color - Yellow\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst YELLOW = rgb(1,1,0);\r\n\r\n/** Color - Green\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst GREEN = rgb(0,1,0);\r\n\r\n/** Color - Cyan\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst CYAN = rgb(0,1,1);\r\n\r\n/** Color - Blue\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst BLUE = rgb(0,0,1);\r\n\r\n/** Color - Purple\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst PURPLE = rgb(.5,0,1);\r\n\r\n/** Color - Magenta\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst MAGENTA = rgb(1,0,1);\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Timer object tracks how long has passed since it was set\r\n * @example\r\n * let a = new Timer;    // creates a timer that is not set\r\n * a.set(3);             // sets the timer to 3 seconds\r\n *\r\n * let b = new Timer(1); // creates a timer with 1 second left\r\n * b.unset();            // unsets the timer\r\n */\r\nclass Timer\r\n{\r\n    /** Create a timer object set time passed in\r\n     *  @param {Number} [timeLeft] - How much time left before the timer elapses in seconds */\r\n    constructor(timeLeft) { this.time = timeLeft == undefined ? undefined : time + timeLeft; this.setTime = timeLeft; }\r\n\r\n    /** Set the timer with seconds passed in\r\n     *  @param {Number} [timeLeft] - How much time left before the timer is elapsed in seconds */\r\n    set(timeLeft=0) { this.time = time + timeLeft; this.setTime = timeLeft; }\r\n\r\n    /** Unset the timer */\r\n    unset() { this.time = undefined; }\r\n\r\n    /** Returns true if set\r\n     * @return {Boolean} */\r\n    isSet() { return this.time != undefined; }\r\n\r\n    /** Returns true if set and has not elapsed\r\n     * @return {Boolean} */\r\n    active() { return time < this.time; }\r\n\r\n    /** Returns true if set and elapsed\r\n     * @return {Boolean} */\r\n    elapsed() { return time >= this.time; }\r\n\r\n    /** Get how long since elapsed, returns 0 if not set (returns negative if currently active)\r\n     * @return {Number} */\r\n    get() { return this.isSet()? time - this.time : 0; }\r\n\r\n    /** Get percentage elapsed based on time it was set to, returns 0 if not set\r\n     * @return {Number} */\r\n    getPercent() { return this.isSet()? percent(this.time - time, this.setTime, 0) : 0; }\r\n    \r\n    /** Returns this timer expressed as a string\r\n     * @return {String} */\r\n    toString() { if (debug) { return this.isSet() ? Math.abs(this.get()) + ' seconds ' + (this.get()<0 ? 'before' : 'after' ) : 'unset'; }}\r\n    \r\n    /** Get how long since elapsed, returns 0 if not set (returns negative if currently active)\r\n     * @return {Number} */\r\n    valueOf()               { return this.get(); }\r\n}\n/**\r\n * LittleJS Engine Settings\r\n * - All settings for the engine are here\r\n * @namespace Settings\r\n */\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Camera settings\r\n\r\n/** Position of camera in world space\r\n *  @type {Vector2}\r\n *  @default Vector2()\r\n *  @memberof Settings */\r\nlet cameraPos = vec2();\r\n\r\n/** Scale of camera in world space\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet cameraScale = 32;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Display settings\r\n\r\n/** The max size of the canvas, centered if window is larger\r\n *  @type {Vector2}\r\n *  @default Vector2(1920,1080)\r\n *  @memberof Settings */\r\nlet canvasMaxSize = vec2(1920, 1080);\r\n\r\n/** Fixed size of the canvas, if enabled canvas size never changes\r\n * - you may also need to set mainCanvasSize if using screen space coords in startup\r\n *  @type {Vector2}\r\n *  @default Vector2()\r\n *  @memberof Settings */\r\nlet canvasFixedSize = vec2();\r\n\r\n/** Disables filtering for crisper pixel art if true\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet canvasPixelated = true;\r\n\r\n/** Default font used for text rendering\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Settings */\r\nlet fontDefault = 'arial';\r\n\r\n/** Enable to show the LittleJS splash screen be shown on startup\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet showSplashScreen = false;\r\n\r\n/** Disables all rendering, audio, and input for servers\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet headlessMode = false;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// WebGL settings\r\n\r\n/** Enable webgl rendering, webgl can be disabled and removed from build (with some features disabled)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet glEnable = true;\r\n\r\n/** Fixes slow rendering in some browsers by not compositing the WebGL canvas\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet glOverlay = true;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Tile sheet settings\r\n\r\n/** Default size of tiles in pixels\r\n *  @type {Vector2}\r\n *  @default Vector2(16,16)\r\n *  @memberof Settings */\r\nlet tileSizeDefault = vec2(16);\r\n\r\n/** How many pixels smaller to draw tiles to prevent bleeding from neighbors\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet tileFixBleedScale = .5;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Object settings\r\n\r\n/** Enable physics solver for collisions between objects\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet enablePhysicsSolver = true;\r\n\r\n/** Default object mass for collision calcuations (how heavy objects are)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultMass = 1;\r\n\r\n/** How much to slow velocity by each frame (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultDamping = 1;\r\n\r\n/** How much to slow angular velocity each frame (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultAngleDamping = 1;\r\n\r\n/** How much to bounce when a collision occurs (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultElasticity = 0;\r\n\r\n/** How much to slow when touching (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultFriction = .8;\r\n\r\n/** Clamp max speed to avoid fast objects missing collisions\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectMaxSpeed = 1;\r\n\r\n/** How much gravity to apply to objects along the Y axis, negative is down\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet gravity = 0;\r\n\r\n/** Scales emit rate of particles, useful for low graphics mode (0 disables particle emitters)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet particleEmitRateScale = 1;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Input settings\r\n\r\n/** Should gamepads be allowed\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet gamepadsEnable = true;\r\n\r\n/** If true, the dpad input is also routed to the left analog stick (for better accessability)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet gamepadDirectionEmulateStick = true;\r\n\r\n/** If true the WASD keys are also routed to the direction keys (for better accessability)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet inputWASDEmulateDirection = true;\r\n\r\n/** True if touch input is enabled for mobile devices\r\n *  - Touch events will be routed to mouse events\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchInputEnable = true;\r\n\r\n/** True if touch gamepad should appear on mobile devices\r\n *  - Supports left analog stick, 4 face buttons and start button (button 9)\r\n *  - Must be set by end of gameInit to be activated\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchGamepadEnable = false;\r\n\r\n/** True if touch gamepad should be analog stick or false to use if 8 way dpad\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchGamepadAnalog = true;\r\n\r\n/** Size of virtual gamepad for touch devices in pixels\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchGamepadSize = 99;\r\n\r\n/** Transparency of touch gamepad overlay\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchGamepadAlpha = .3;\r\n\r\n/** Allow vibration hardware if it exists\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet vibrateEnable = true;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Audio settings\r\n\r\n/** All audio code can be disabled and removed from build\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet soundEnable = true;\r\n\r\n/** Volume scale to apply to all sound, music and speech\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet soundVolume = .3;\r\n\r\n/** Default range where sound no longer plays\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet soundDefaultRange = 40;\r\n\r\n/** Default range percent to start tapering off sound (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet soundDefaultTaper = .7;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Medals settings\r\n\r\n/** How long to show medals for in seconds\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet medalDisplayTime = 5;\r\n\r\n/** How quickly to slide on/off medals in seconds\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet medalDisplaySlideTime = .5;\r\n\r\n/** Size of medal display\r\n *  @type {Vector2}\r\n *  @default Vector2(640,80)\r\n *  @memberof Settings */\r\nlet medalDisplaySize = vec2(640, 80);\r\n\r\n/** Size of icon in medal display\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet medalDisplayIconSize = 50;\r\n\r\n/** Set to stop medals from being unlockable (like if cheats are enabled)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet medalsPreventUnlock = false;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Setters for global variables\r\n\r\n/** Set position of camera in world space\r\n *  @param {Vector2} pos\r\n *  @memberof Settings */\r\nfunction setCameraPos(pos) { cameraPos = pos; }\r\n\r\n/** Set scale of camera in world space\r\n *  @param {Number} scale\r\n *  @memberof Settings */\r\nfunction setCameraScale(scale) { cameraScale = scale; }\r\n\r\n/** Set max size of the canvas\r\n *  @param {Vector2} size\r\n *  @memberof Settings */\r\nfunction setCanvasMaxSize(size) { canvasMaxSize = size; }\r\n\r\n/** Set fixed size of the canvas\r\n *  @param {Vector2} size\r\n *  @memberof Settings */\r\nfunction setCanvasFixedSize(size) { canvasFixedSize = size; }\r\n\r\n/** Disables anti aliasing for pixel art if true\r\n *  @param {Boolean} pixelated\r\n *  @memberof Settings */\r\nfunction setCanvasPixelated(pixelated) { canvasPixelated = pixelated; }\r\n\r\n/** Set default font used for text rendering\r\n *  @param {String} font\r\n *  @memberof Settings */\r\nfunction setFontDefault(font) { fontDefault = font; }\r\n\r\n/** Set if the LittleJS splash screen be shown on startup\r\n *  @param {Boolean} show\r\n *  @memberof Settings */\r\nfunction setShowSplashScreen(show) { showSplashScreen = show; }\r\n\r\n/** Set to disalbe rendering, audio, and input for servers\r\n *  @param {Boolean} headless\r\n *  @memberof Settings */\r\nfunction setHeadlessMode(headless) { headlessMode = headless; }\r\n\r\n/** Set if webgl rendering is enabled\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setGlEnable(enable) { glEnable = enable; }\r\n\r\n/** Set to not composite the WebGL canvas\r\n *  @param {Boolean} overlay\r\n *  @memberof Settings */\r\nfunction setGlOverlay(overlay) { glOverlay = overlay; }\r\n\r\n/** Set default size of tiles in pixels\r\n *  @param {Vector2} size\r\n *  @memberof Settings */\r\nfunction setTileSizeDefault(size) { tileSizeDefault = size; }\r\n\r\n/** Set to prevent tile bleeding from neighbors in pixels\r\n *  @param {Number} scale\r\n *  @memberof Settings */\r\nfunction setTileFixBleedScale(scale) { tileFixBleedScale = scale; }\r\n\r\n/** Set if collisions between objects are enabled\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setEnablePhysicsSolver(enable) { enablePhysicsSolver = enable; }\r\n\r\n/** Set default object mass for collison calcuations\r\n *  @param {Number} mass\r\n *  @memberof Settings */\r\nfunction setObjectDefaultMass(mass) { objectDefaultMass = mass; }\r\n\r\n/** Set how much to slow velocity by each frame\r\n *  @param {Number} damp\r\n *  @memberof Settings */\r\nfunction setObjectDefaultDamping(damp) { objectDefaultDamping = damp; }\r\n\r\n/** Set how much to slow angular velocity each frame\r\n *  @param {Number} damp\r\n *  @memberof Settings */\r\nfunction setObjectDefaultAngleDamping(damp) { objectDefaultAngleDamping = damp; }\r\n\r\n/** Set how much to bounce when a collision occur\r\n *  @param {Number} elasticity\r\n *  @memberof Settings */\r\nfunction setObjectDefaultElasticity(elasticity) { objectDefaultElasticity = elasticity; }\r\n\r\n/** Set how much to slow when touching\r\n *  @param {Number} friction\r\n *  @memberof Settings */\r\nfunction setObjectDefaultFriction(friction) { objectDefaultFriction = friction; }\r\n\r\n/** Set max speed to avoid fast objects missing collisions\r\n *  @param {Number} speed\r\n *  @memberof Settings */\r\nfunction setObjectMaxSpeed(speed) { objectMaxSpeed = speed; }\r\n\r\n/** Set how much gravity to apply to objects along the Y axis\r\n *  @param {Number} newGravity\r\n *  @memberof Settings */\r\nfunction setGravity(newGravity) { gravity = newGravity; }\r\n\r\n/** Set to scales emit rate of particles\r\n *  @param {Number} scale\r\n *  @memberof Settings */\r\nfunction setParticleEmitRateScale(scale) { particleEmitRateScale = scale; }\r\n\r\n/** Set if gamepads are enabled\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setGamepadsEnable(enable) { gamepadsEnable = enable; }\r\n\r\n/** Set if the dpad input is also routed to the left analog stick\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setGamepadDirectionEmulateStick(enable) { gamepadDirectionEmulateStick = enable; }\r\n\r\n/** Set if true the WASD keys are also routed to the direction keys\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setInputWASDEmulateDirection(enable) { inputWASDEmulateDirection = enable; }\r\n\r\n/** Set if touch input is allowed\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setTouchInputEnable(enable) { touchInputEnable = enable; }\r\n\r\n/** Set if touch gamepad should appear on mobile devices\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setTouchGamepadEnable(enable) { touchGamepadEnable = enable; }\r\n\r\n/** Set if touch gamepad should be analog stick or 8 way dpad\r\n *  @param {Boolean} analog\r\n *  @memberof Settings */\r\nfunction setTouchGamepadAnalog(analog) { touchGamepadAnalog = analog; }\r\n\r\n/** Set size of virutal gamepad for touch devices in pixels\r\n *  @param {Number} size\r\n *  @memberof Settings */\r\nfunction setTouchGamepadSize(size) { touchGamepadSize = size; }\r\n\r\n/** Set transparency of touch gamepad overlay\r\n *  @param {Number} alpha\r\n *  @memberof Settings */\r\nfunction setTouchGamepadAlpha(alpha) { touchGamepadAlpha = alpha; }\r\n\r\n/** Set to allow vibration hardware if it exists\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setVibrateEnable(enable) { vibrateEnable = enable; }\r\n\r\n/** Set to disable all audio code\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setSoundEnable(enable) { soundEnable = enable; }\r\n\r\n/** Set volume scale to apply to all sound, music and speech\r\n *  @param {Number} volume\r\n *  @memberof Settings */\r\nfunction setSoundVolume(volume)\r\n{\r\n    soundVolume = volume;\r\n    if (soundEnable && !headlessMode && audioGainNode)\r\n        audioGainNode.gain.value = volume; // update gain immediatly\r\n}\r\n\r\n/** Set default range where sound no longer plays\r\n *  @param {Number} range\r\n *  @memberof Settings */\r\nfunction setSoundDefaultRange(range) { soundDefaultRange = range; }\r\n\r\n/** Set default range percent to start tapering off sound\r\n *  @param {Number} taper\r\n *  @memberof Settings */\r\nfunction setSoundDefaultTaper(taper) { soundDefaultTaper = taper; }\r\n\r\n/** Set how long to show medals for in seconds\r\n *  @param {Number} time\r\n *  @memberof Settings */\r\nfunction setMedalDisplayTime(time) { medalDisplayTime = time; }\r\n\r\n/** Set how quickly to slide on/off medals in seconds\r\n *  @param {Number} time\r\n *  @memberof Settings */\r\nfunction setMedalDisplaySlideTime(time) { medalDisplaySlideTime = time; }\r\n\r\n/** Set size of medal display\r\n *  @param {Vector2} size\r\n *  @memberof Settings */\r\nfunction setMedalDisplaySize(size) { medalDisplaySize = size; }\r\n\r\n/** Set size of icon in medal display\r\n *  @param {Number} size\r\n *  @memberof Settings */\r\nfunction setMedalDisplayIconSize(size) { medalDisplayIconSize = size; }\r\n\r\n/** Set to stop medals from being unlockable\r\n *  @param {Boolean} preventUnlock\r\n *  @memberof Settings */\r\nfunction setMedalsPreventUnlock(preventUnlock) { medalsPreventUnlock = preventUnlock; }\r\n\r\n/** Set if watermark with FPS should be shown\r\n *  @param {Boolean} show\r\n *  @memberof Debug */\r\nfunction setShowWatermark(show) { showWatermark = show; }\r\n\r\n/** Set key code used to toggle debug mode, Esc by default\r\n *  @param {String} key\r\n *  @memberof Debug */\r\nfunction setDebugKey(key) { debugKey = key; }\n/** \r\n * LittleJS Object System\r\n */\r\n\r\n\r\n\r\n/** \r\n * LittleJS Object Base Object Class\r\n * - Top level object class used by the engine\r\n * - Automatically adds self to object list\r\n * - Will be updated and rendered each frame\r\n * - Renders as a sprite from a tilesheet by default\r\n * - Can have color and additive color applied\r\n * - 2D Physics and collision system\r\n * - Sorted by renderOrder\r\n * - Objects can have children attached\r\n * - Parents are updated before children, and set child transform\r\n * - Call destroy() to get rid of objects\r\n *\r\n * The physics system used by objects is simple and fast with some caveats...\r\n * - Collision uses the axis aligned size, the object's rotation angle is only for rendering\r\n * - Objects are guaranteed to not intersect tile collision from physics\r\n * - If an object starts or is moved inside tile collision, it will not collide with that tile\r\n * - Collision for objects can be set to be solid to block other objects\r\n * - Objects may get pushed into overlapping other solid objects, if so they will push away\r\n * - Solid objects are more performance intensive and should be used sparingly\r\n * @example\r\n * // create an engine object, normally you would first extend the class with your own\r\n * const pos = vec2(2,3);\r\n * const object = new EngineObject(pos); \r\n */\r\nclass EngineObject\r\n{\r\n    /** Create an engine object and adds it to the list of objects\r\n     *  @param {Vector2}  [pos=(0,0)]       - World space position of the object\r\n     *  @param {Vector2}  [size=(1,1)]      - World space size of the object\r\n     *  @param {TileInfo} [tileInfo]        - Tile info to render object (undefined is untextured)\r\n     *  @param {Number}   [angle]           - Angle the object is rotated by\r\n     *  @param {Color}    [color=(1,1,1,1)] - Color to apply to tile when rendered\r\n     *  @param {Number}   [renderOrder]     - Objects sorted by renderOrder before being rendered\r\n     */\r\n    constructor(pos=vec2(), size=vec2(1), tileInfo, angle=0, color, renderOrder=0)\r\n    {\r\n        // set passed in params\r\n        ASSERT(isVector2(pos) && isVector2(size), 'ensure pos and size are vec2s');\r\n        ASSERT(typeof tileInfo !== 'number' || !tileInfo, 'old style tile setup');\r\n\r\n        /** @property {Vector2} - World space position of the object */\r\n        this.pos = pos.copy();\r\n        /** @property {Vector2} - World space width and height of the object */\r\n        this.size = size;\r\n        /** @property {Vector2} - Size of object used for drawing, uses size if not set */\r\n        this.drawSize = undefined;\r\n        /** @property {TileInfo} - Tile info to render object (undefined is untextured) */\r\n        this.tileInfo = tileInfo;\r\n        /** @property {Number}  - Angle to rotate the object */\r\n        this.angle = angle;\r\n        /** @property {Color}   - Color to apply when rendered */\r\n        this.color = color;\r\n        /** @property {Color}   - Additive color to apply when rendered */\r\n        this.additiveColor = undefined;\r\n        /** @property {Boolean} - Should it flip along y axis when rendered */\r\n        this.mirror = false;\r\n\r\n        // physical properties\r\n        /** @property {Number} [mass=objectDefaultMass]                 - How heavy the object is, static if 0 */\r\n        this.mass         = objectDefaultMass;\r\n        /** @property {Number} [damping=objectDefaultDamping]           - How much to slow down velocity each frame (0-1) */\r\n        this.damping      = objectDefaultDamping;\r\n        /** @property {Number} [angleDamping=objectDefaultAngleDamping] - How much to slow down rotation each frame (0-1) */\r\n        this.angleDamping = objectDefaultAngleDamping;\r\n        /** @property {Number} [elasticity=objectDefaultElasticity]     - How bouncy the object is when colliding (0-1) */\r\n        this.elasticity   = objectDefaultElasticity;\r\n        /** @property {Number} [friction=objectDefaultFriction]         - How much friction to apply when sliding (0-1) */\r\n        this.friction     = objectDefaultFriction;\r\n        /** @property {Number}  - How much to scale gravity by for this object */\r\n        this.gravityScale = 1;\r\n        /** @property {Number}  - Objects are sorted by render order */\r\n        this.renderOrder = renderOrder;\r\n        /** @property {Vector2} - Velocity of the object */\r\n        this.velocity = vec2();\r\n        /** @property {Number}  - Angular velocity of the object */\r\n        this.angleVelocity = 0;\r\n        /** @property {Number}  - Track when object was created  */\r\n        this.spawnTime = time;\r\n        /** @property {Array}   - List of children of this object */\r\n        this.children = [];\r\n        /** @property {Boolean}  - Limit object speed using linear or circular math */\r\n        this.clampSpeedLinear = true;\r\n\r\n        // parent child system\r\n        /** @property {EngineObject} - Parent of object if in local space  */\r\n        this.parent = undefined;\r\n        /** @property {Vector2}      - Local position if child */\r\n        this.localPos = vec2();\r\n        /** @property {Number}       - Local angle if child  */\r\n        this.localAngle = 0;\r\n\r\n        // collision flags\r\n        /** @property {Boolean} - Object collides with the tile collision */\r\n        this.collideTiles = false;\r\n        /** @property {Boolean} - Object collides with solid objects */\r\n        this.collideSolidObjects = false;\r\n        /** @property {Boolean} - Object collides with and blocks other objects */\r\n        this.isSolid = false;\r\n        /** @property {Boolean} - Object collides with raycasts */\r\n        this.collideRaycast = false;\r\n\r\n        // add to list of objects\r\n        engineObjects.push(this);\r\n    }\r\n    \r\n    /** Update the object transform, called automatically by engine even when paused */\r\n    updateTransforms()\r\n    {\r\n        const parent = this.parent;\r\n        if (parent)\r\n        {\r\n            // copy parent pos/angle\r\n            const mirror = parent.getMirrorSign();\r\n            this.pos = this.localPos.multiply(vec2(mirror,1)).rotate(-parent.angle).add(parent.pos);\r\n            this.angle = mirror*this.localAngle + parent.angle;\r\n        }\r\n\r\n        // update children\r\n        for (const child of this.children)\r\n            child.updateTransforms();\r\n    }\r\n\r\n    /** Update the object physics, called automatically by engine once each frame */\r\n    update()\r\n    {\r\n        // child objects do not have physics\r\n        if (this.parent)\r\n            return;\r\n\r\n        // limit max speed to prevent missing collisions\r\n        if (this.clampSpeedLinear)\r\n        {\r\n            this.velocity.x = clamp(this.velocity.x, -objectMaxSpeed, objectMaxSpeed);\r\n            this.velocity.y = clamp(this.velocity.y, -objectMaxSpeed, objectMaxSpeed);\r\n        }\r\n        else\r\n        {\r\n            const length2 = this.velocity.lengthSquared();\r\n            if (length2 > objectMaxSpeed*objectMaxSpeed)\r\n            {\r\n                const s = objectMaxSpeed / length2**.5;\r\n                this.velocity.x *= s;\r\n                this.velocity.y *= s;\r\n            }\r\n        }\r\n\r\n        // apply physics\r\n        const oldPos = this.pos.copy();\r\n        this.pos.x += this.velocity.x *= this.damping;\r\n        this.pos.y += this.velocity.y = this.damping * this.velocity.y \r\n            + gravity * this.gravityScale;\r\n        this.angle += this.angleVelocity *= this.angleDamping;\r\n\r\n        // physics sanity checks\r\n        ASSERT(this.angleDamping >= 0 && this.angleDamping <= 1);\r\n        ASSERT(this.damping >= 0 && this.damping <= 1);\r\n        if (!enablePhysicsSolver || !this.mass) // dont do collision for fixed objects\r\n            return;\r\n\r\n        const wasMovingDown = this.velocity.y < 0;\r\n        if (this.groundObject)\r\n        {\r\n            // apply friction in local space of ground object\r\n            const groundSpeed = this.groundObject.velocity ? this.groundObject.velocity.x : 0;\r\n            this.velocity.x = groundSpeed + (this.velocity.x - groundSpeed) * this.friction;\r\n            this.groundObject = 0;\r\n            //debugOverlay && debugPhysics && debugPoint(this.pos.subtract(vec2(0,this.size.y/2)), '#0f0');\r\n        }\r\n\r\n        if (this.collideSolidObjects)\r\n        {\r\n            // check collisions against solid objects\r\n            const epsilon = .001; // necessary to push slightly outside of the collision\r\n            for (const o of engineObjectsCollide)\r\n            {\r\n                // non solid objects don't collide with eachother\r\n                if (!this.isSolid && !o.isSolid || o.destroyed || o.parent || o == this)\r\n                    continue;\r\n\r\n                // check collision\r\n                if (!isOverlapping(this.pos, this.size, o.pos, o.size))\r\n                    continue;\r\n\r\n                // notify objects of collision and check if should be resolved\r\n                const collide1 = this.collideWithObject(o);\r\n                const collide2 = o.collideWithObject(this);\r\n                if (!collide1 || !collide2)\r\n                    continue;\r\n\r\n                if (isOverlapping(oldPos, this.size, o.pos, o.size))\r\n                {\r\n                    // if already was touching, try to push away\r\n                    const deltaPos = oldPos.subtract(o.pos);\r\n                    const length = deltaPos.length();\r\n                    const pushAwayAccel = .001; // push away if already overlapping\r\n                    const velocity = length < .01 ? randVector(pushAwayAccel) : deltaPos.scale(pushAwayAccel/length);\r\n                    this.velocity = this.velocity.add(velocity);\r\n                    if (o.mass) // push away if not fixed\r\n                        o.velocity = o.velocity.subtract(velocity);\r\n                        \r\n                    debugOverlay && debugPhysics && debugOverlap(this.pos, this.size, o.pos, o.size, '#f00');\r\n                    continue;\r\n                }\r\n\r\n                // check for collision\r\n                const sizeBoth = this.size.add(o.size);\r\n                const smallStepUp = (oldPos.y - o.pos.y)*2 > sizeBoth.y + gravity; // prefer to push up if small delta\r\n                const isBlockedX = abs(oldPos.y - o.pos.y)*2 < sizeBoth.y;\r\n                const isBlockedY = abs(oldPos.x - o.pos.x)*2 < sizeBoth.x;\r\n                const elasticity = max(this.elasticity, o.elasticity);\r\n                \r\n                if (smallStepUp || isBlockedY || !isBlockedX) // resolve y collision\r\n                {\r\n                    // push outside object collision\r\n                    this.pos.y = o.pos.y + (sizeBoth.y/2 + epsilon) * sign(oldPos.y - o.pos.y);\r\n                    if (o.groundObject && wasMovingDown || !o.mass)\r\n                    {\r\n                        // set ground object if landed on something\r\n                        if (wasMovingDown)\r\n                            this.groundObject = o;\r\n\r\n                        // bounce if other object is fixed or grounded\r\n                        this.velocity.y *= -elasticity;\r\n                    }\r\n                    else if (o.mass)\r\n                    {\r\n                        // inelastic collision\r\n                        const inelastic = (this.mass * this.velocity.y + o.mass * o.velocity.y) / (this.mass + o.mass);\r\n\r\n                        // elastic collision\r\n                        const elastic0 = this.velocity.y * (this.mass - o.mass) / (this.mass + o.mass)\r\n                            + o.velocity.y * 2 * o.mass / (this.mass + o.mass);\r\n                        const elastic1 = o.velocity.y * (o.mass - this.mass) / (this.mass + o.mass)\r\n                            + this.velocity.y * 2 * this.mass / (this.mass + o.mass);\r\n\r\n                        // lerp betwen elastic or inelastic based on elasticity\r\n                        this.velocity.y = lerp(elasticity, inelastic, elastic0);\r\n                        o.velocity.y = lerp(elasticity, inelastic, elastic1);\r\n                    }\r\n                }\r\n                if (!smallStepUp && isBlockedX) // resolve x collision\r\n                {\r\n                    // push outside collision\r\n                    this.pos.x = o.pos.x + (sizeBoth.x/2 + epsilon) * sign(oldPos.x - o.pos.x);\r\n                    if (o.mass)\r\n                    {\r\n                        // inelastic collision\r\n                        const inelastic = (this.mass * this.velocity.x + o.mass * o.velocity.x) / (this.mass + o.mass);\r\n\r\n                        // elastic collision\r\n                        const elastic0 = this.velocity.x * (this.mass - o.mass) / (this.mass + o.mass)\r\n                            + o.velocity.x * 2 * o.mass / (this.mass + o.mass);\r\n                        const elastic1 = o.velocity.x * (o.mass - this.mass) / (this.mass + o.mass)\r\n                            + this.velocity.x * 2 * this.mass / (this.mass + o.mass);\r\n\r\n                        // lerp betwen elastic or inelastic based on elasticity\r\n                        this.velocity.x = lerp(elasticity, inelastic, elastic0);\r\n                        o.velocity.x = lerp(elasticity, inelastic, elastic1);\r\n                    }\r\n                    else // bounce if other object is fixed\r\n                        this.velocity.x *= -elasticity;\r\n                }\r\n                debugOverlay && debugPhysics && debugOverlap(this.pos, this.size, o.pos, o.size, '#f0f');\r\n            }\r\n        }\r\n        if (this.collideTiles)\r\n        {\r\n            // check collision against tiles\r\n            if (tileCollisionTest(this.pos, this.size, this))\r\n            {\r\n                // if already was stuck in collision, don't do anything\r\n                // this should not happen unless something starts in collision\r\n                if (!tileCollisionTest(oldPos, this.size, this))\r\n                {\r\n                    // test which side we bounced off (or both if a corner)\r\n                    const isBlockedY = tileCollisionTest(vec2(oldPos.x, this.pos.y), this.size, this);\r\n                    const isBlockedX = tileCollisionTest(vec2(this.pos.x, oldPos.y), this.size, this);\r\n                    if (isBlockedY || !isBlockedX)\r\n                    {\r\n                        // bounce velocity\r\n                        this.velocity.y *= -this.elasticity;\r\n\r\n                        // set if landed on ground\r\n                        if (this.groundObject = wasMovingDown)\r\n                        {\r\n                            // adjust position to slightly above nearest tile boundary\r\n                            // this prevents gap between object and ground\r\n                            const epsilon = .0001;\r\n                            this.pos.y = (oldPos.y-this.size.y/2|0)+this.size.y/2+epsilon;\r\n                        }\r\n                        else\r\n                        {\r\n                            // move to previous position\r\n                            this.pos.y = oldPos.y;\r\n                        }\r\n                    }\r\n                    if (isBlockedX)\r\n                    {\r\n                        // move to previous position and bounce\r\n                        this.pos.x = oldPos.x;\r\n                        this.velocity.x *= -this.elasticity;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n       \r\n    /** Render the object, draws a tile by default, automatically called each frame, sorted by renderOrder */\r\n    render()\r\n    {\r\n        // default object render\r\n        drawTile(this.pos, this.drawSize || this.size, this.tileInfo, this.color, this.angle, this.mirror, this.additiveColor);\r\n    }\r\n    \r\n    /** Destroy this object, destroy it's children, detach it's parent, and mark it for removal */\r\n    destroy()\r\n    { \r\n        if (this.destroyed)\r\n            return;\r\n        \r\n        // disconnect from parent and destroy chidren\r\n        this.destroyed = 1;\r\n        this.parent && this.parent.removeChild(this);\r\n        for (const child of this.children)\r\n            child.destroy(child.parent = 0);\r\n    }\r\n\r\n    /** Convert from local space to world space\r\n     *  @param {Vector2} pos - local space point */\r\n    localToWorld(pos) { return this.pos.add(pos.rotate(-this.angle)); }\r\n\r\n    /** Convert from world space to local space\r\n     *  @param {Vector2} pos - world space point */\r\n    worldToLocal(pos) { return pos.subtract(this.pos).rotate(this.angle); }\r\n\r\n    /** Convert from local space to world space for a vector (rotation only)\r\n     *  @param {Vector2} vec - local space vector */\r\n    localToWorldVector(vec) { return vec.rotate(this.angle); }\r\n\r\n    /** Convert from world space to local space for a vector (rotation only)\r\n     *  @param {Vector2} vec - world space vector */\r\n    worldToLocalVector(vec) { return vec.rotate(-this.angle); }\r\n    \r\n    /** Called to check if a tile collision should be resolved\r\n     *  @param {Number}  tileData - the value of the tile at the position\r\n     *  @param {Vector2} pos      - tile where the collision occured\r\n     *  @return {Boolean}         - true if the collision should be resolved */\r\n    collideWithTile(tileData, pos)    { return tileData > 0; }\r\n\r\n    /** Called to check if a object collision should be resolved\r\n     *  @param {EngineObject} object - the object to test against\r\n     *  @return {Boolean}            - true if the collision should be resolved\r\n     */\r\n    collideWithObject(object)         { return true; }\r\n\r\n    /** How long since the object was created\r\n     *  @return {Number} */\r\n    getAliveTime()                    { return time - this.spawnTime; }\r\n\r\n    /** Apply acceleration to this object (adjust velocity, not affected by mass)\r\n     *  @param {Vector2} acceleration */\r\n    applyAcceleration(acceleration)   { if (this.mass) this.velocity = this.velocity.add(acceleration); }\r\n\r\n    /** Apply force to this object (adjust velocity, affected by mass)\r\n     *  @param {Vector2} force */\r\n    applyForce(force)\t              { this.applyAcceleration(force.scale(1/this.mass)); }\r\n    \r\n    /** Get the direction of the mirror\r\n     *  @return {Number} -1 if this.mirror is true, or 1 if not mirrored */\r\n    getMirrorSign() { return this.mirror ? -1 : 1; }\r\n\r\n    /** Attaches a child to this with a given local transform\r\n     *  @param {EngineObject} child\r\n     *  @param {Vector2}      [localPos=(0,0)]\r\n     *  @param {Number}       [localAngle] */\r\n    addChild(child, localPos=vec2(), localAngle=0)\r\n    {\r\n        ASSERT(!child.parent && !this.children.includes(child));\r\n        this.children.push(child);\r\n        child.parent = this;\r\n        child.localPos = localPos.copy();\r\n        child.localAngle = localAngle;\r\n    }\r\n\r\n    /** Removes a child from this one\r\n     *  @param {EngineObject} child */\r\n    removeChild(child)\r\n    {\r\n        ASSERT(child.parent == this && this.children.includes(child));\r\n        this.children.splice(this.children.indexOf(child), 1);\r\n        child.parent = 0;\r\n    }\r\n\r\n    /** Set how this object collides\r\n     *  @param {Boolean} [collideSolidObjects] - Does it collide with solid objects?\r\n     *  @param {Boolean} [isSolid]             - Does it collide with and block other objects? (expensive in large numbers)\r\n     *  @param {Boolean} [collideTiles]        - Does it collide with the tile collision?\r\n     *  @param {Boolean} [collideRaycast]      - Does it collide with raycasts? */\r\n    setCollision(collideSolidObjects=true, isSolid=true, collideTiles=true, collideRaycast=true)\r\n    {\r\n        ASSERT(collideSolidObjects || !isSolid, 'solid objects must be set to collide');\r\n\r\n        this.collideSolidObjects = collideSolidObjects;\r\n        this.isSolid = isSolid;\r\n        this.collideTiles = collideTiles;\r\n        this.collideRaycast = collideRaycast;\r\n    }\r\n\r\n    /** Returns string containg info about this object for debugging\r\n     *  @return {String} */\r\n    toString()\r\n    {\r\n        if (debug)\r\n        {\r\n            let text = 'type = ' + this.constructor.name;\r\n            if (this.pos.x || this.pos.y)\r\n                text += '\\npos = ' + this.pos;\r\n            if (this.velocity.x || this.velocity.y)\r\n                text += '\\nvelocity = ' + this.velocity;\r\n            if (this.size.x || this.size.y)\r\n                text += '\\nsize = ' + this.size;\r\n            if (this.angle)\r\n                text += '\\nangle = ' + this.angle.toFixed(3);\r\n            if (this.color)\r\n                text += '\\ncolor = ' + this.color;\r\n            return text;\r\n        }\r\n    }\r\n\r\n    /** Render debug info for this object  */\r\n    renderDebugInfo()\r\n    {\r\n        if (debug)\r\n        {\r\n            // show object info for debugging\r\n            const size = vec2(max(this.size.x, .2), max(this.size.y, .2));\r\n            const color1 = rgb(this.collideTiles?1:0, this.collideSolidObjects?1:0, this.isSolid?1:0, this.parent?.2:.5);\r\n            const color2 = this.parent ? rgb(1,1,1,.5) : rgb(0,0,0,.8);\r\n            drawRect(this.pos, size, color1, this.angle, false);\r\n            drawRect(this.pos, size.scale(.8), color2, this.angle, false);\r\n            this.parent && drawLine(this.pos, this.parent.pos, .1, rgb(0,0,1,.5), false);\r\n        }\r\n    }\r\n}\n/** \r\n * LittleJS Drawing System\r\n * - Hybrid system with both Canvas2D and WebGL available\r\n * - Super fast tile sheet rendering with WebGL\r\n * - Can apply rotation, mirror, color and additive color\r\n * - Font rendering system with built in engine font\r\n * - Many useful utility functions\r\n * \r\n * LittleJS uses a hybrid rendering solution with the best of both Canvas2D and WebGL.\r\n * There are 3 canvas/contexts available to draw to...\r\n * mainCanvas - 2D background canvas, non WebGL stuff like tile layers are drawn here.\r\n * glCanvas - Used by the accelerated WebGL batch rendering system.\r\n * overlayCanvas - Another 2D canvas that appears on top of the other 2 canvases.\r\n * \r\n * The WebGL rendering system is very fast with some caveats...\r\n * - Switching blend modes (additive) or textures causes another draw call which is expensive in excess\r\n * - Group additive rendering together using renderOrder to mitigate this issue\r\n * \r\n * The LittleJS rendering solution is intentionally simple, feel free to adjust it for your needs!\r\n * @namespace Draw\r\n */\r\n\r\n\r\n\r\n/** The primary 2D canvas visible to the user\r\n *  @type {HTMLCanvasElement}\r\n *  @memberof Draw */\r\nlet mainCanvas;\r\n\r\n/** 2d context for mainCanvas\r\n *  @type {CanvasRenderingContext2D}\r\n *  @memberof Draw */\r\nlet mainContext;\r\n\r\n/** A canvas that appears on top of everything the same size as mainCanvas\r\n *  @type {HTMLCanvasElement}\r\n *  @memberof Draw */\r\nlet overlayCanvas;\r\n\r\n/** 2d context for overlayCanvas\r\n *  @type {CanvasRenderingContext2D}\r\n *  @memberof Draw */\r\nlet overlayContext;\r\n\r\n/** The size of the main canvas (and other secondary canvases) \r\n *  @type {Vector2}\r\n *  @memberof Draw */\r\nlet mainCanvasSize = vec2();\r\n\r\n/** Array containing texture info for batch rendering system\r\n *  @type {Array}\r\n *  @memberof Draw */\r\nlet textureInfos = [];\r\n\r\n// Keep track of how many draw calls there were each frame for debugging\r\nlet drawCount;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Create a tile info object\r\n * - This can take vecs or floats for easier use and conversion\r\n * - If an index is passed in, the tile size and index will determine the position\r\n * @param {(Number|Vector2)} [pos=(0,0)]            - Top left corner of tile in pixels or index\r\n * @param {(Number|Vector2)} [size=tileSizeDefault] - Size of tile in pixels\r\n * @param {Number} [textureIndex]                   - Texture index to use\r\n * @return {TileInfo}\r\n * @example\r\n * tile(2)                       // a tile at index 2 using the default tile size of 16\r\n * tile(5, 8)                    // a tile at index 5 using a tile size of 8\r\n * tile(1, 16, 3)                // a tile at index 1 of size 16 on texture 3\r\n * tile(vec2(4,8), vec2(30,10))  // a tile at pixel location (4,8) with a size of (30,10)\r\n * @memberof Draw\r\n */\r\nfunction tile(pos=vec2(), size=tileSizeDefault, textureIndex=0)\r\n{\r\n    if (headlessMode)\r\n        return new TileInfo;\r\n\r\n    // if size is a number, make it a vector\r\n    if (typeof size === 'number')\r\n    {\r\n        ASSERT(size > 0);\r\n        size = vec2(size);\r\n    }\r\n\r\n    // if pos is a number, use it as a tile index\r\n    if (typeof pos === 'number')\r\n    {\r\n        const textureInfo = textureInfos[textureIndex];\r\n        ASSERT(textureInfo, 'Texture not loaded');\r\n        const cols = textureInfo.size.x / size.x |0;\r\n        pos = vec2((pos%cols)*size.x, (pos/cols|0)*size.y);\r\n    }\r\n\r\n    // return a tile info object\r\n    return new TileInfo(pos, size, textureIndex); \r\n}\r\n\r\n/** \r\n * Tile Info - Stores info about how to draw a tile\r\n */\r\nclass TileInfo\r\n{\r\n    /** Create a tile info object\r\n     *  @param {Vector2} [pos=(0,0)]            - Top left corner of tile in pixels\r\n     *  @param {Vector2} [size=tileSizeDefault] - Size of tile in pixels\r\n     *  @param {Number}  [textureIndex]         - Texture index to use\r\n     */\r\n    constructor(pos=vec2(), size=tileSizeDefault, textureIndex=0)\r\n    {\r\n        /** @property {Vector2} - Top left corner of tile in pixels */\r\n        this.pos = pos.copy();\r\n        /** @property {Vector2} - Size of tile in pixels */\r\n        this.size = size.copy();\r\n        /** @property {Number} - Texture index to use */\r\n        this.textureIndex = textureIndex;\r\n    }\r\n\r\n    /** Returns a copy of this tile offset by a vector\r\n    *  @param {Vector2} offset - Offset to apply in pixels\r\n    *  @return {TileInfo}\r\n    */\r\n    offset(offset)\r\n    { return new TileInfo(this.pos.add(offset), this.size, this.textureIndex); }\r\n\r\n    /** Returns a copy of this tile offset by a number of animation frames\r\n    *  @param {Number} frame - Offset to apply in animation frames\r\n    *  @return {TileInfo}\r\n    */\r\n    frame(frame)\r\n    {\r\n        ASSERT(typeof frame == 'number');\r\n        return this.offset(vec2(frame*this.size.x, 0));\r\n    }\r\n\r\n    /** Returns the texture info for this tile\r\n    *  @return {TextureInfo}\r\n    */\r\n    getTextureInfo()\r\n    { return textureInfos[this.textureIndex]; }\r\n}\r\n\r\n/** Texture Info - Stores info about each texture */\r\nclass TextureInfo\r\n{\r\n    /**\r\n     * Create a TextureInfo, called automatically by the engine\r\n     * @param {HTMLImageElement} image\r\n     */\r\n    constructor(image)\r\n    {\r\n        /** @property {HTMLImageElement} - image source */\r\n        this.image = image;\r\n        /** @property {Vector2} - size of the image */\r\n        this.size = vec2(image.width, image.height);\r\n        /** @property {WebGLTexture} - webgl texture */\r\n        this.glTexture = glEnable && glCreateTexture(image);\r\n        /** @property {Vector2} - size to adjust tile to fix bleeding */\r\n        this.fixBleedSize = vec2(tileFixBleedScale).divide(this.size);\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Convert from screen to world space coordinates\r\n *  @param {Vector2} screenPos\r\n *  @return {Vector2}\r\n *  @memberof Draw */\r\nfunction screenToWorld(screenPos)\r\n{\r\n    return new Vector2\r\n    (\r\n        (screenPos.x - mainCanvasSize.x/2 + .5) /  cameraScale + cameraPos.x,\r\n        (screenPos.y - mainCanvasSize.y/2 + .5) / -cameraScale + cameraPos.y\r\n    );\r\n}\r\n\r\n/** Convert from world to screen space coordinates\r\n *  @param {Vector2} worldPos\r\n *  @return {Vector2}\r\n *  @memberof Draw */\r\nfunction worldToScreen(worldPos)\r\n{\r\n    return new Vector2\r\n    (\r\n        (worldPos.x - cameraPos.x) *  cameraScale + mainCanvasSize.x/2 - .5,\r\n        (worldPos.y - cameraPos.y) * -cameraScale + mainCanvasSize.y/2 - .5\r\n    );\r\n}\r\n\r\n/** Get the camera's visible area in world space\r\n *  @return {Vector2}\r\n *  @memberof Draw */\r\nfunction getCameraSize() { return mainCanvasSize.scale(1/cameraScale); }\r\n\r\n/** Draw textured tile centered in world space, with color applied if using WebGL\r\n *  @param {Vector2} pos                        - Center of the tile in world space\r\n *  @param {Vector2} [size=(1,1)]               - Size of the tile in world space\r\n *  @param {TileInfo}[tileInfo]                 - Tile info to use, untextured if undefined\r\n *  @param {Color}   [color=(1,1,1,1)]          - Color to modulate with\r\n *  @param {Number}  [angle]                    - Angle to rotate by\r\n *  @param {Boolean} [mirror]                   - If true image is flipped along the Y axis\r\n *  @param {Color}   [additiveColor=(0,0,0,0)]  - Additive color to be applied\r\n *  @param {Boolean} [useWebGL=glEnable]        - Use accelerated WebGL rendering\r\n *  @param {Boolean} [screenSpace=false]        - If true the pos and size are in screen space\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context] - Canvas 2D context to draw to\r\n *  @memberof Draw */\r\nfunction drawTile(pos, size=vec2(1), tileInfo, color=new Color,\r\n    angle=0, mirror, additiveColor=new Color(0,0,0,0), useWebGL=glEnable, screenSpace, context)\r\n{\r\n    ASSERT(!context || !useWebGL, 'context only supported in canvas 2D mode'); \r\n    ASSERT(typeof tileInfo !== 'number' || !tileInfo, \r\n        'this is an old style calls, to fix replace it with tile(tileIndex, tileSize)');\r\n\r\n    const textureInfo = tileInfo && tileInfo.getTextureInfo();\r\n    if (useWebGL)\r\n    {\r\n        if (screenSpace)\r\n        {\r\n            // convert to world space\r\n            pos = screenToWorld(pos);\r\n            size = size.scale(1/cameraScale);\r\n        }\r\n        \r\n        if (textureInfo)\r\n        {\r\n            // calculate uvs and render\r\n            const x = tileInfo.pos.x / textureInfo.size.x;\r\n            const y = tileInfo.pos.y / textureInfo.size.y;\r\n            const w = tileInfo.size.x / textureInfo.size.x;\r\n            const h = tileInfo.size.y / textureInfo.size.y;\r\n            const tileImageFixBleed = textureInfo.fixBleedSize;\r\n            glSetTexture(textureInfo.glTexture);\r\n            glDraw(pos.x, pos.y, mirror ? -size.x : size.x, size.y, angle, \r\n                x + tileImageFixBleed.x,     y + tileImageFixBleed.y, \r\n                x - tileImageFixBleed.x + w, y - tileImageFixBleed.y + h, \r\n                color.rgbaInt(), additiveColor.rgbaInt()); \r\n        }\r\n        else\r\n        {\r\n            // if no tile info, force untextured\r\n            glDraw(pos.x, pos.y, size.x, size.y, angle, 0, 0, 0, 0, 0, color.rgbaInt()); \r\n        }\r\n    }\r\n    else\r\n    {\r\n        // normal canvas 2D rendering method (slower)\r\n        showWatermark && ++drawCount;\r\n        drawCanvas2D(pos, size, angle, mirror, (context)=>\r\n        {\r\n            if (textureInfo)\r\n            {\r\n                // calculate uvs and render\r\n                const x = tileInfo.pos.x + tileFixBleedScale;\r\n                const y = tileInfo.pos.y + tileFixBleedScale;\r\n                const w = tileInfo.size.x - 2*tileFixBleedScale;\r\n                const h = tileInfo.size.y - 2*tileFixBleedScale;\r\n                context.globalAlpha = color.a; // only alpha is supported\r\n                context.drawImage(textureInfo.image, x, y, w, h, -.5, -.5, 1, 1);\r\n                context.globalAlpha = 1; // set back to full alpha\r\n            }\r\n            else\r\n            {\r\n                // if no tile info, force untextured\r\n                context.fillStyle = color;\r\n                context.fillRect(-.5, -.5, 1, 1);\r\n            }\r\n        }, screenSpace, context);\r\n    }\r\n}\r\n\r\n/** Draw colored rect centered on pos\r\n *  @param {Vector2} pos\r\n *  @param {Vector2} [size=(1,1)]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Number}  [angle]\r\n *  @param {Boolean} [useWebGL=glEnable]\r\n *  @param {Boolean} [screenSpace=false]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context]\r\n *  @memberof Draw */\r\nfunction drawRect(pos, size, color, angle, useWebGL, screenSpace, context)\r\n{ \r\n    drawTile(pos, size, undefined, color, angle, false, undefined, useWebGL, screenSpace, context); \r\n}\r\n\r\n/** Draw colored line between two points\r\n *  @param {Vector2} posA\r\n *  @param {Vector2} posB\r\n *  @param {Number}  [thickness]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Boolean} [useWebGL=glEnable]\r\n *  @param {Boolean} [screenSpace=false]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context]\r\n *  @memberof Draw */\r\nfunction drawLine(posA, posB, thickness=.1, color, useWebGL, screenSpace, context)\r\n{\r\n    const halfDelta = vec2((posB.x - posA.x)/2, (posB.y - posA.y)/2);\r\n    const size = vec2(thickness, halfDelta.length()*2);\r\n    drawRect(posA.add(halfDelta), size, color, halfDelta.angle(), useWebGL, screenSpace, context);\r\n}\r\n\r\n/** Draw directly to a 2d canvas context in world space\r\n *  @param {Vector2}  pos\r\n *  @param {Vector2}  size\r\n *  @param {Number}   angle\r\n *  @param {Boolean}  mirror\r\n *  @param {Function} drawFunction\r\n *  @param {Boolean} [screenSpace=false]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=mainContext]\r\n *  @memberof Draw */\r\nfunction drawCanvas2D(pos, size, angle, mirror, drawFunction, screenSpace, context=mainContext)\r\n{\r\n    if (!screenSpace)\r\n    {\r\n        // transform from world space to screen space\r\n        pos = worldToScreen(pos);\r\n        size = size.scale(cameraScale);\r\n    }\r\n    context.save();\r\n    context.translate(pos.x+.5, pos.y+.5);\r\n    context.rotate(angle);\r\n    context.scale(mirror ? -size.x : size.x, -size.y);\r\n    drawFunction(context);\r\n    context.restore();\r\n}\r\n\r\n/** Enable normal or additive blend mode\r\n *  @param {Boolean} [additive]\r\n *  @param {Boolean} [useWebGL=glEnable]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=mainContext]\r\n *  @memberof Draw */\r\nfunction setBlendMode(additive, useWebGL=glEnable, context)\r\n{\r\n    ASSERT(!context || !useWebGL, 'context only supported in canvas 2D mode');\r\n    if (useWebGL)\r\n        glAdditive = additive;\r\n    else\r\n    {\r\n        if (!context)\r\n            context = mainContext;\r\n        context.globalCompositeOperation = additive ? 'lighter' : 'source-over';\r\n    }\r\n}\r\n\r\n/** Draw text on overlay canvas in world space\r\n *  Automatically splits new lines into rows\r\n *  @param {String}  text\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [size]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Number}  [lineWidth]\r\n *  @param {Color}   [lineColor=(0,0,0,1)]\r\n *  @param {CanvasTextAlign}  [textAlign='center']\r\n *  @param {String}  [font=fontDefault]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=overlayContext]\r\n *  @memberof Draw */\r\nfunction drawText(text, pos, size=1, color, lineWidth=0, lineColor, textAlign, font, context)\r\n{\r\n    drawTextScreen(text, worldToScreen(pos), size*cameraScale, color, lineWidth*cameraScale, lineColor, textAlign, font, context);\r\n}\r\n\r\n/** Draw text on overlay canvas in screen space\r\n *  Automatically splits new lines into rows\r\n *  @param {String}  text\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [size]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Number}  [lineWidth]\r\n *  @param {Color}   [lineColor=(0,0,0,1)]\r\n *  @param {CanvasTextAlign}  [textAlign]\r\n *  @param {String}  [font=fontDefault]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=overlayContext]\r\n *  @memberof Draw */\r\nfunction drawTextScreen(text, pos, size=1, color=new Color, lineWidth=0, lineColor=new Color(0,0,0), textAlign='center', font=fontDefault, context=overlayContext)\r\n{\r\n    context.fillStyle = color.toString();\r\n    context.lineWidth = lineWidth;\r\n    context.strokeStyle = lineColor.toString();\r\n    context.textAlign = textAlign;\r\n    context.font = size + 'px '+ font;\r\n    context.textBaseline = 'middle';\r\n    context.lineJoin = 'round';\r\n\r\n    pos = pos.copy();\r\n    (text+'').split('\\n').forEach(line=>\r\n    {\r\n        lineWidth && context.strokeText(line, pos.x, pos.y);\r\n        context.fillText(line, pos.x, pos.y);\r\n        pos.y += size;\r\n    });\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nlet engineFontImage;\r\n\r\n/** \r\n * Font Image Object - Draw text on a 2D canvas by using characters in an image\r\n * - 96 characters (from space to tilde) are stored in an image\r\n * - Uses a default 8x8 font if none is supplied\r\n * - You can also use fonts from the main tile sheet\r\n * @example\r\n * // use built in font\r\n * const font = new ImageFont;\r\n * \r\n * // draw text\r\n * font.drawTextScreen(\"LittleJS\\nHello World!\", vec2(200, 50));\r\n */\r\nclass FontImage\r\n{\r\n    /** Create an image font\r\n     *  @param {HTMLImageElement} [image]    - Image for the font, if undefined default font is used\r\n     *  @param {Vector2} [tileSize=(8,8)]    - Size of the font source tiles\r\n     *  @param {Vector2} [paddingSize=(0,1)] - How much extra space to add between characters\r\n     *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=overlayContext] - context to draw to\r\n     */\r\n    constructor(image, tileSize=vec2(8), paddingSize=vec2(0,1), context=overlayContext)\r\n    {\r\n        // load default font image\r\n        if (!engineFontImage)\r\n            (engineFontImage = new Image).src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAYAQAAAAA9+x6JAAAAAnRSTlMAAHaTzTgAAAGiSURBVHjaZZABhxxBEIUf6ECLBdFY+Q0PMNgf0yCgsSAGZcT9sgIPtBWwIA5wgAPEoHUyJeeSlW+gjK+fegWwtROWpVQEyWh2npdpBmTUFVhb29RINgLIukoXr5LIAvYQ5ve+1FqWEMqNKTX3FAJHyQDRZvmKWubAACcv5z5Gtg2oyCWE+Yk/8JZQX1jTTCpKAFGIgza+dJCNBF2UskRlsgwitHbSV0QLgt9sTPtsRlvJjEr8C/FARWA2bJ/TtJ7lko34dNDn6usJUMzuErP89UUBJbWeozrwLLncXczd508deAjLWipLO4Q5XGPcJvPu92cNDaN0P5G1FL0nSOzddZOrJ6rNhbXGmeDvO3TF7DeJWl4bvaYQTNHCTeuqKZmbjHaSOFes+IX/+IhHrnAkXOAsfn24EM68XieIECoccD4KZLk/odiwzeo2rovYdhvb2HYFgyznJyDpYJdYOmfXgVdJTaUi4xA2uWYNYec9BLeqdl9EsoTw582mSFDX2DxVLbNt9U3YYoeatBad1c2Tj8t2akrjaIGJNywKB/7h75/gN3vCMSaadIUTAAAAAElFTkSuQmCC';\r\n\r\n        this.image = image || engineFontImage;\r\n        this.tileSize = tileSize;\r\n        this.paddingSize = paddingSize;\r\n        this.context = context;\r\n    }\r\n\r\n    /** Draw text in world space using the image font\r\n     *  @param {String}  text\r\n     *  @param {Vector2} pos\r\n     *  @param {Number}  [scale=.25]\r\n     *  @param {Boolean} [center]\r\n     */\r\n    drawText(text, pos, scale=1, center)\r\n    {\r\n        this.drawTextScreen(text, worldToScreen(pos).floor(), scale*cameraScale|0, center);\r\n    }\r\n\r\n    /** Draw text in screen space using the image font\r\n     *  @param {String}  text\r\n     *  @param {Vector2} pos\r\n     *  @param {Number}  [scale]\r\n     *  @param {Boolean} [center]\r\n     */\r\n    drawTextScreen(text, pos, scale=4, center)\r\n    {\r\n        const context = this.context;\r\n        context.save();\r\n        context.imageSmoothingEnabled = !canvasPixelated;\r\n\r\n        const size = this.tileSize;\r\n        const drawSize = size.add(this.paddingSize).scale(scale);\r\n        const cols = this.image.width / this.tileSize.x |0;\r\n        (text+'').split('\\n').forEach((line, i)=>\r\n        {\r\n            const centerOffset = center ? line.length * size.x * scale / 2 |0 : 0;\r\n            for(let j=line.length; j--;)\r\n            {\r\n                // draw each character\r\n                let charCode = line[j].charCodeAt(0);\r\n                if (charCode < 32 || charCode > 127)\r\n                    charCode = 127; // unknown character\r\n\r\n                // get the character source location and draw it\r\n                const tile = charCode - 32;\r\n                const x = tile % cols;\r\n                const y = tile / cols |0;\r\n                const drawPos = pos.add(vec2(j,i).multiply(drawSize));\r\n                context.drawImage(this.image, x * size.x, y * size.y, size.x, size.y, \r\n                    drawPos.x - centerOffset, drawPos.y, size.x * scale, size.y * scale);\r\n            }\r\n        });\r\n\r\n        context.restore();\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Fullscreen mode\r\n\r\n/** Returns true if fullscreen mode is active\r\n *  @return {Boolean}\r\n *  @memberof Draw */\r\nfunction isFullscreen() { return !!document.fullscreenElement; }\r\n\r\n/** Toggle fullsceen mode\r\n *  @memberof Draw */\r\nfunction toggleFullscreen()\r\n{\r\n    if (isFullscreen())\r\n    {\r\n        if (document.exitFullscreen)\r\n            document.exitFullscreen();\r\n    }\r\n    else if (document.body.requestFullscreen)\r\n            document.body.requestFullscreen();\r\n}\n/** \r\n * LittleJS Input System\r\n * - Tracks keyboard down, pressed, and released\r\n * - Tracks mouse buttons, position, and wheel\r\n * - Tracks multiple analog gamepads\r\n * - Touch input is handled as mouse input\r\n * - Virtual gamepad for touch devices\r\n * @namespace Input\r\n */\r\n\r\n\r\n\r\n/** Returns true if device key is down\r\n *  @param {String|Number} key\r\n *  @param {Number} [device]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction keyIsDown(key, device=0)\r\n{ \r\n    ASSERT(device > 0 || typeof key !== 'number' || key < 3, 'use code string for keyboard');\r\n    return inputData[device] && !!(inputData[device][key] & 1); \r\n}\r\n\r\n/** Returns true if device key was pressed this frame\r\n *  @param {String|Number} key\r\n *  @param {Number} [device]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction keyWasPressed(key, device=0)\r\n{ \r\n    ASSERT(device > 0 || typeof key !== 'number' || key < 3, 'use code string for keyboard');\r\n    return inputData[device] && !!(inputData[device][key] & 2); \r\n}\r\n\r\n/** Returns true if device key was released this frame\r\n *  @param {String|Number} key\r\n *  @param {Number} [device]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction keyWasReleased(key, device=0)\r\n{ \r\n    ASSERT(device > 0 || typeof key !== 'number' || key < 3, 'use code string for keyboard');\r\n    return inputData[device] && !!(inputData[device][key] & 4);\r\n}\r\n\r\n/** Clears all input\r\n *  @memberof Input */\r\nfunction clearInput() { inputData = [[]]; }\r\n\r\n/** Returns true if mouse button is down\r\n *  @function\r\n *  @param {Number} button\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nconst mouseIsDown = keyIsDown;\r\n\r\n/** Returns true if mouse button was pressed\r\n *  @function\r\n *  @param {Number} button\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nconst mouseWasPressed = keyWasPressed;\r\n\r\n/** Returns true if mouse button was released\r\n *  @function\r\n *  @param {Number} button\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nconst mouseWasReleased = keyWasReleased;\r\n\r\n/** Mouse pos in world space\r\n *  @type {Vector2}\r\n *  @memberof Input */\r\nlet mousePos = vec2();\r\n\r\n/** Mouse pos in screen space\r\n *  @type {Vector2}\r\n *  @memberof Input */\r\nlet mousePosScreen = vec2();\r\n\r\n/** Mouse wheel delta this frame\r\n *  @type {Number}\r\n *  @memberof Input */\r\nlet mouseWheel = 0;\r\n\r\n/** Returns true if user is using gamepad (has more recently pressed a gamepad button)\r\n *  @type {Boolean}\r\n *  @memberof Input */\r\nlet isUsingGamepad = false;\r\n\r\n/** Prevents input continuing to the default browser handling (false by default)\r\n *  @type {Boolean}\r\n *  @memberof Input */\r\nlet preventDefaultInput = false;\r\n\r\n/** Returns true if gamepad button is down\r\n *  @param {Number} button\r\n *  @param {Number} [gamepad]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction gamepadIsDown(button, gamepad=0)\r\n{ return keyIsDown(button, gamepad+1); }\r\n\r\n/** Returns true if gamepad button was pressed\r\n *  @param {Number} button\r\n *  @param {Number} [gamepad]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction gamepadWasPressed(button, gamepad=0)\r\n{ return keyWasPressed(button, gamepad+1); }\r\n\r\n/** Returns true if gamepad button was released\r\n *  @param {Number} button\r\n *  @param {Number} [gamepad]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction gamepadWasReleased(button, gamepad=0)\r\n{ return keyWasReleased(button, gamepad+1); }\r\n\r\n/** Returns gamepad stick value\r\n *  @param {Number} stick\r\n *  @param {Number} [gamepad]\r\n *  @return {Vector2}\r\n *  @memberof Input */\r\nfunction gamepadStick(stick,  gamepad=0)\r\n{ return gamepadStickData[gamepad] ? gamepadStickData[gamepad][stick] || vec2() : vec2(); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Input update called by engine\r\n\r\n// store input as a bit field for each key: 1 = isDown, 2 = wasPressed, 4 = wasReleased\r\n// mouse and keyboard are stored together in device 0, gamepads are in devices > 0\r\nlet inputData = [[]];\r\n\r\nfunction inputUpdate()\r\n{\r\n    if (headlessMode) return;\r\n\r\n    // clear input when lost focus (prevent stuck keys)\r\n    if(!(touchInputEnable && isTouchDevice) && !document.hasFocus())\r\n        clearInput();\r\n\r\n    // update mouse world space position\r\n    mousePos = screenToWorld(mousePosScreen);\r\n\r\n    // update gamepads if enabled\r\n    gamepadsUpdate();\r\n}\r\n\r\nfunction inputUpdatePost()\r\n{\r\n    if (headlessMode) return;\r\n\r\n    // clear input to prepare for next frame\r\n    for (const deviceInputData of inputData)\r\n    for (const i in deviceInputData)\r\n        deviceInputData[i] &= 1;\r\n    mouseWheel = 0;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Input event handlers\r\n\r\nfunction inputInit()\r\n{\r\n    if (headlessMode) return;\r\n\r\n    onkeydown = (e)=>\r\n    {\r\n        if (debug && e.target != document.body) return;\r\n        if (!e.repeat)\r\n        {\r\n            isUsingGamepad = false;\r\n            inputData[0][e.code] = 3;\r\n            if (inputWASDEmulateDirection)\r\n                inputData[0][remapKey(e.code)] = 3;\r\n        }\r\n        preventDefaultInput && e.preventDefault();\r\n    }\r\n\r\n    onkeyup = (e)=>\r\n    {\r\n        if (debug && e.target != document.body) return;\r\n        inputData[0][e.code] = 4;\r\n        if (inputWASDEmulateDirection)\r\n            inputData[0][remapKey(e.code)] = 4;\r\n    }\r\n\r\n    // handle remapping wasd keys to directions\r\n    function remapKey(c)\r\n    {\r\n        return inputWASDEmulateDirection ? \r\n            c == 'KeyW' ? 'ArrowUp' : \r\n            c == 'KeyS' ? 'ArrowDown' : \r\n            c == 'KeyA' ? 'ArrowLeft' : \r\n            c == 'KeyD' ? 'ArrowRight' : c : c;\r\n    }\r\n    \r\n    // mouse event handlers\r\n    onmousedown   = (e)=>\r\n    {\r\n        // fix stalled audio requiring user interaction\r\n        if (soundEnable && !headlessMode && audioContext && audioContext.state != 'running')\r\n            audioContext.resume();\r\n        \r\n        isUsingGamepad = false; \r\n        inputData[0][e.button] = 3; \r\n        mousePosScreen = mouseToScreen(e); \r\n        e.button && e.preventDefault();\r\n    }\r\n    onmouseup     = (e)=> inputData[0][e.button] = inputData[0][e.button] & 2 | 4;\r\n    onmousemove   = (e)=> mousePosScreen = mouseToScreen(e);\r\n    onwheel       = (e)=> mouseWheel = e.ctrlKey ? 0 : sign(e.deltaY);\r\n    oncontextmenu = (e)=> false; // prevent right click menu\r\n\r\n    // init touch input\r\n    if (isTouchDevice && touchInputEnable)\r\n        touchInputInit();\r\n}\r\n\r\n// convert a mouse or touch event position to screen space\r\nfunction mouseToScreen(mousePos)\r\n{\r\n    if (!mainCanvas || headlessMode)\r\n        return vec2(); // fix bug that can occur if user clicks before page loads\r\n\r\n    const rect = mainCanvas.getBoundingClientRect();\r\n    return vec2(mainCanvas.width, mainCanvas.height).multiply(\r\n        vec2(percent(mousePos.x, rect.left, rect.right), percent(mousePos.y, rect.top, rect.bottom)));\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Gamepad input\r\n\r\n// gamepad internal variables\r\nconst gamepadStickData = [];\r\n\r\n// gamepads are updated by engine every frame automatically\r\nfunction gamepadsUpdate()\r\n{\r\n    const applyDeadZones = (v)=>\r\n    {\r\n        const min=.3, max=.8;\r\n        const deadZone = (v)=> \r\n            v >  min ?  percent( v, min, max) : \r\n            v < -min ? -percent(-v, min, max) : 0;\r\n        return vec2(deadZone(v.x), deadZone(-v.y)).clampLength();\r\n    }\r\n\r\n    // update touch gamepad if enabled\r\n    if (touchGamepadEnable && isTouchDevice)\r\n    {\r\n        ASSERT(touchGamepadButtons, 'set touchGamepadEnable before calling init!');\r\n        if (touchGamepadTimer.isSet())\r\n        {\r\n            // read virtual analog stick\r\n            const sticks = gamepadStickData[0] || (gamepadStickData[0] = []);\r\n            sticks[0] = vec2();\r\n            if (touchGamepadAnalog)\r\n                sticks[0] = applyDeadZones(touchGamepadStick);\r\n            else if (touchGamepadStick.lengthSquared() > .3)\r\n            {\r\n                // convert to 8 way dpad\r\n                sticks[0].x = Math.round(touchGamepadStick.x);\r\n                sticks[0].y = -Math.round(touchGamepadStick.y);\r\n                sticks[0] = sticks[0].clampLength();\r\n            }\r\n\r\n            // read virtual gamepad buttons\r\n            const data = inputData[1] || (inputData[1] = []);\r\n            for (let i=10; i--;)\r\n            {\r\n                const j = i == 3 ? 2 : i == 2 ? 3 : i; // fix button locations\r\n                const wasDown = gamepadIsDown(j,0);\r\n                data[j] = touchGamepadButtons[i] ? wasDown ? 1 : 3 : wasDown ? 4 : 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // return if gamepads are disabled or not supported\r\n    if (!gamepadsEnable || !navigator || !navigator.getGamepads)\r\n        return;\r\n\r\n    // only poll gamepads when focused or in debug mode\r\n    if (!debug && !document.hasFocus())\r\n        return;\r\n\r\n    // poll gamepads\r\n    const gamepads = navigator.getGamepads();\r\n    for (let i = gamepads.length; i--;)\r\n    {\r\n        // get or create gamepad data\r\n        const gamepad = gamepads[i];\r\n        const data = inputData[i+1] || (inputData[i+1] = []);\r\n        const sticks = gamepadStickData[i] || (gamepadStickData[i] = []);\r\n\r\n        if (gamepad)\r\n        {\r\n            // read analog sticks\r\n            for (let j = 0; j < gamepad.axes.length-1; j+=2)\r\n                sticks[j>>1] = applyDeadZones(vec2(gamepad.axes[j],gamepad.axes[j+1]));\r\n            \r\n            // read buttons\r\n            for (let j = gamepad.buttons.length; j--;)\r\n            {\r\n                const button = gamepad.buttons[j];\r\n                const wasDown = gamepadIsDown(j,i);\r\n                data[j] = button.pressed ? wasDown ? 1 : 3 : wasDown ? 4 : 0;\r\n                isUsingGamepad ||= !i && button.pressed;\r\n            }\r\n\r\n            if (gamepadDirectionEmulateStick)\r\n            {\r\n                // copy dpad to left analog stick when pressed\r\n                const dpad = vec2(\r\n                    (gamepadIsDown(15,i)&&1) - (gamepadIsDown(14,i)&&1), \r\n                    (gamepadIsDown(12,i)&&1) - (gamepadIsDown(13,i)&&1));\r\n                if (dpad.lengthSquared())\r\n                    sticks[0] = dpad.clampLength();\r\n            }\r\n\r\n            // disable touch gamepad if using real gamepad\r\n            touchGamepadEnable && isUsingGamepad && touchGamepadTimer.unset(); \r\n        }\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Pulse the vibration hardware if it exists\r\n *  @param {Number|Array} [pattern] - single value in ms or vibration interval array\r\n *  @memberof Input */\r\nfunction vibrate(pattern=100)\r\n{ vibrateEnable && !headlessMode && navigator && navigator.vibrate && navigator.vibrate(pattern); }\r\n\r\n/** Cancel any ongoing vibration\r\n *  @memberof Input */\r\nfunction vibrateStop() { vibrate(0); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Touch input & virtual on screen gamepad\r\n\r\n/** True if a touch device has been detected\r\n *  @memberof Input */\r\nconst isTouchDevice = window.ontouchstart !== undefined;\r\n\r\n// touch gamepad internal variables\r\nlet touchGamepadTimer = new Timer, touchGamepadButtons, touchGamepadStick;\r\n\r\n// enable touch input mouse passthrough\r\nfunction touchInputInit()\r\n{\r\n    // add non passive touch event listeners\r\n    let handleTouch = handleTouchDefault;\r\n    if (touchGamepadEnable)\r\n    {\r\n        // touch input internal variables\r\n        handleTouch = handleTouchGamepad;\r\n        touchGamepadButtons = [];\r\n        touchGamepadStick = vec2();\r\n    }\r\n    document.addEventListener('touchstart', (e) => handleTouch(e), { passive: false });\r\n    document.addEventListener('touchmove',  (e) => handleTouch(e), { passive: false });\r\n    document.addEventListener('touchend',   (e) => handleTouch(e), { passive: false });\r\n\r\n    // override mouse events\r\n    onmousedown = onmouseup = ()=> 0;\r\n\r\n    // handle all touch events the same way\r\n    let wasTouching;\r\n    function handleTouchDefault(e)\r\n    {\r\n        // fix stalled audio requiring user interaction\r\n        if (soundEnable && !headlessMode && audioContext && audioContext.state != 'running')\r\n            audioContext.resume();\r\n\r\n        // check if touching and pass to mouse events\r\n        const touching = e.touches.length;\r\n        const button = 0; // all touches are left mouse button\r\n        if (touching)\r\n        {\r\n            // set event pos and pass it along\r\n            const p = vec2(e.touches[0].clientX, e.touches[0].clientY);\r\n            mousePosScreen = mouseToScreen(p);\r\n            wasTouching ? isUsingGamepad = false : inputData[0][button] = 3;\r\n        }\r\n        else if (wasTouching)\r\n            inputData[0][button] = inputData[0][button] & 2 | 4;\r\n\r\n        // set was touching\r\n        wasTouching = touching;\r\n\r\n        // prevent default handling like copy and magnifier lens\r\n        if (document.hasFocus()) // allow document to get focus\r\n            e.preventDefault();\r\n        \r\n        // must return true so the document will get focus\r\n        return true;\r\n    }\r\n\r\n    // special handling for virtual gamepad mode\r\n    function handleTouchGamepad(e)\r\n    {\r\n        // clear touch gamepad input\r\n        touchGamepadStick = vec2();\r\n        touchGamepadButtons = [];\r\n        isUsingGamepad = true;\r\n            \r\n        const touching = e.touches.length;\r\n        if (touching)\r\n        {\r\n            touchGamepadTimer.set();\r\n            if (paused)\r\n            {\r\n                // touch anywhere to press start when paused\r\n                touchGamepadButtons[9] = 1;\r\n                return;\r\n            }\r\n        }\r\n\r\n        // get center of left and right sides\r\n        const stickCenter = vec2(touchGamepadSize, mainCanvasSize.y-touchGamepadSize);\r\n        const buttonCenter = mainCanvasSize.subtract(vec2(touchGamepadSize, touchGamepadSize));\r\n        const startCenter = mainCanvasSize.scale(.5);\r\n\r\n        // check each touch point\r\n        for (const touch of e.touches)\r\n        {\r\n            const touchPos = mouseToScreen(vec2(touch.clientX, touch.clientY));\r\n            if (touchPos.distance(stickCenter) < touchGamepadSize)\r\n            {\r\n                // virtual analog stick\r\n                touchGamepadStick = touchPos.subtract(stickCenter).scale(2/touchGamepadSize).clampLength();\r\n            }\r\n            else if (touchPos.distance(buttonCenter) < touchGamepadSize)\r\n            {\r\n                // virtual face buttons\r\n                const button = touchPos.subtract(buttonCenter).direction();\r\n                touchGamepadButtons[button] = 1;\r\n            }\r\n            else if (touchPos.distance(startCenter) < touchGamepadSize)\r\n            {\r\n                // virtual start button in center\r\n                touchGamepadButtons[9] = 1;\r\n            }\r\n        }\r\n\r\n        // call default touch handler so normal touch events still work\r\n        handleTouchDefault(e);\r\n        \r\n        // must return true so the document will get focus\r\n        return true;\r\n    }\r\n}\r\n\r\n// render the touch gamepad, called automatically by the engine\r\nfunction touchGamepadRender()\r\n{\r\n    if (!touchInputEnable || !isTouchDevice || headlessMode) return;\r\n    if (!touchGamepadEnable || !touchGamepadTimer.isSet())\r\n        return;\r\n    \r\n    // fade off when not touching or paused\r\n    const alpha = percent(touchGamepadTimer.get(), 4, 3);\r\n    if (!alpha || paused)\r\n        return;\r\n\r\n    // setup the canvas\r\n    const context = overlayContext;\r\n    context.save();\r\n    context.globalAlpha = alpha*touchGamepadAlpha;\r\n    context.strokeStyle = '#fff';\r\n    context.lineWidth = 3;\r\n\r\n    // draw left analog stick\r\n    context.fillStyle = touchGamepadStick.lengthSquared() > 0 ? '#fff' : '#000';\r\n    context.beginPath();\r\n\r\n    const leftCenter = vec2(touchGamepadSize, mainCanvasSize.y-touchGamepadSize);\r\n    if (touchGamepadAnalog) // draw circle shaped gamepad\r\n    {\r\n        context.arc(leftCenter.x, leftCenter.y, touchGamepadSize/2, 0, 9);\r\n        context.fill();\r\n        context.stroke();\r\n    }\r\n    else // draw cross shaped gamepad\r\n    {\r\n        for(let i=10; i--;)\r\n        {\r\n            const angle = i*PI/4;\r\n            context.arc(leftCenter.x, leftCenter.y,touchGamepadSize*.6, angle + PI/8, angle + PI/8);\r\n            i%2 && context.arc(leftCenter.x, leftCenter.y, touchGamepadSize*.33, angle, angle);\r\n            i==1 && context.fill();\r\n        }\r\n        context.stroke();\r\n    }\r\n    \r\n    // draw right face buttons\r\n    const rightCenter = vec2(mainCanvasSize.x-touchGamepadSize, mainCanvasSize.y-touchGamepadSize);\r\n    for (let i=4; i--;)\r\n    {\r\n        const pos = rightCenter.add(vec2().setDirection(i, touchGamepadSize/2));\r\n        context.fillStyle = touchGamepadButtons[i] ? '#fff' : '#000';\r\n        context.beginPath();\r\n        context.arc(pos.x, pos.y, touchGamepadSize/4, 0,9);\r\n        context.fill();\r\n        context.stroke();\r\n    }\r\n\r\n    // set canvas back to normal\r\n    context.restore();\r\n}\n/** \r\n * LittleJS Audio System\r\n * - <a href=https://killedbyapixel.github.io/ZzFX/>ZzFX Sound Effects</a> - ZzFX Sound Effect Generator\r\n * - <a href=https://keithclark.github.io/ZzFXM/>ZzFXM Music</a> - ZzFXM Music System\r\n * - Caches sounds and music for fast playback\r\n * - Can attenuate and apply stereo panning to sounds\r\n * - Ability to play mp3, ogg, and wave files\r\n * - Speech synthesis functions\r\n * @namespace Audio\r\n */\r\n\r\n\r\n\r\n/** Audio context used by the engine\r\n *  @type {AudioContext}\r\n *  @memberof Audio */\r\nlet audioContext;\r\n\r\n/** Master gain node for all audio to pass through\r\n *  @type {GainNode}\r\n *  @memberof Audio */\r\nlet audioGainNode;\r\n\r\nfunction audioInit()\r\n{\r\n    if (!soundEnable || headlessMode) return;\r\n    \r\n    // create audio context\r\n    audioContext = new AudioContext;\r\n\r\n    // create and connect gain node\r\n    // (createGain is more widely spported then GainNode construtor)\r\n    audioGainNode = audioContext.createGain();\r\n    audioGainNode.connect(audioContext.destination);\r\n    setSoundVolume(soundVolume); // update gain volume\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Sound Object - Stores a sound for later use and can be played positionally\r\n * \r\n * <a href=https://killedbyapixel.github.io/ZzFX/>Create sounds using the ZzFX Sound Designer.</a>\r\n * @example\r\n * // create a sound\r\n * const sound_example = new Sound([.5,.5]);\r\n * \r\n * // play the sound\r\n * sound_example.play();\r\n */\r\nclass Sound\r\n{\r\n    /** Create a sound object and cache the zzfx samples for later use\r\n     *  @param {Array}  zzfxSound - Array of zzfx parameters, ex. [.5,.5]\r\n     *  @param {Number} [range=soundDefaultRange] - World space max range of sound, will not play if camera is farther away\r\n     *  @param {Number} [taper=soundDefaultTaper] - At what percentage of range should it start tapering\r\n     */\r\n    constructor(zzfxSound, range=soundDefaultRange, taper=soundDefaultTaper)\r\n    {\r\n        if (!soundEnable || headlessMode) return;\r\n\r\n        /** @property {Number} - World space max range of sound, will not play if camera is farther away */\r\n        this.range = range;\r\n\r\n        /** @property {Number} - At what percentage of range should it start tapering off */\r\n        this.taper = taper;\r\n\r\n        /** @property {Number} - How much to randomize frequency each time sound plays */\r\n        this.randomness = 0;\r\n\r\n        if (zzfxSound)\r\n        {\r\n            // generate zzfx sound now for fast playback\r\n            const defaultRandomness = .05;\r\n            this.randomness = zzfxSound[1] || defaultRandomness;\r\n            zzfxSound[1] = 0; // generate without randomness\r\n            this.sampleChannels = [zzfxG(...zzfxSound)];\r\n            this.sampleRate = zzfxR;\r\n        }\r\n    }\r\n\r\n    /** Play the sound\r\n     *  @param {Vector2} [pos] - World space position to play the sound, sound is not attenuated if null\r\n     *  @param {Number}  [volume] - How much to scale volume by (in addition to range fade)\r\n     *  @param {Number}  [pitch] - How much to scale pitch by (also adjusted by this.randomness)\r\n     *  @param {Number}  [randomnessScale] - How much to scale randomness\r\n     *  @param {Boolean} [loop] - Should the sound loop\r\n     *  @return {AudioBufferSourceNode} - The audio source node\r\n     */\r\n    play(pos, volume=1, pitch=1, randomnessScale=1, loop=false)\r\n    {\r\n        if (!soundEnable || headlessMode) return;\r\n        if (!this.sampleChannels) return;\r\n\r\n        let pan;\r\n        if (pos)\r\n        {\r\n            const range = this.range;\r\n            if (range)\r\n            {\r\n                // apply range based fade\r\n                const lengthSquared = cameraPos.distanceSquared(pos);\r\n                if (lengthSquared > range*range)\r\n                    return; // out of range\r\n\r\n                // attenuate volume by distance\r\n                volume *= percent(lengthSquared**.5, range, range*this.taper);\r\n            }\r\n\r\n            // get pan from screen space coords\r\n            pan = worldToScreen(pos).x * 2/mainCanvas.width - 1;\r\n        }\r\n\r\n        // play the sound\r\n        const playbackRate = pitch + pitch * this.randomness*randomnessScale*rand(-1,1);\r\n        this.gainNode = audioContext.createGain();\r\n        return this.source = playSamples(this.sampleChannels, volume, playbackRate, pan, loop, this.sampleRate, this.gainNode);\r\n    }\r\n\r\n    /** Set the sound volume\r\n     *  @param {Number}  [volume] - How much to scale volume by\r\n     */\r\n    setVolume(volume=1)\r\n    {\r\n        if (this.gainNode)\r\n            this.gainNode.gain.value = volume;\r\n    }\r\n\r\n    /** Stop the last instance of this sound that was played */\r\n    stop()\r\n    {\r\n        if (this.source)\r\n            this.source.stop();\r\n        this.source = undefined;\r\n    }\r\n    \r\n    /** Get source of most recent instance of this sound that was played\r\n     *  @return {AudioBufferSourceNode}\r\n     */\r\n    getSource() { return this.source; }\r\n\r\n    /** Play the sound as a note with a semitone offset\r\n     *  @param {Number}  semitoneOffset - How many semitones to offset pitch\r\n     *  @param {Vector2} [pos] - World space position to play the sound, sound is not attenuated if null\r\n     *  @param {Number}  [volume=1] - How much to scale volume by (in addition to range fade)\r\n     *  @return {AudioBufferSourceNode} - The audio source node\r\n     */\r\n    playNote(semitoneOffset, pos, volume)\r\n    { return this.play(pos, volume, 2**(semitoneOffset/12), 0); }\r\n\r\n    /** Get how long this sound is in seconds\r\n     *  @return {Number} - How long the sound is in seconds (undefined if loading)\r\n     */\r\n    getDuration() \r\n    { return this.sampleChannels && this.sampleChannels[0].length / this.sampleRate; }\r\n    \r\n    /** Check if sound is loading, for sounds fetched from a url\r\n     *  @return {Boolean} - True if sound is loading and not ready to play\r\n     */\r\n    isLoading() { return !this.sampleChannels; }\r\n}\r\n\r\n/** \r\n * Sound Wave Object - Stores a wave sound for later use and can be played positionally\r\n * - this can be used to play wave, mp3, and ogg files\r\n * @example\r\n * // create a sound\r\n * const sound_example = new SoundWave('sound.mp3');\r\n * \r\n * // play the sound\r\n * sound_example.play();\r\n */\r\nclass SoundWave extends Sound\r\n{\r\n    /** Create a sound object and cache the wave file for later use\r\n     *  @param {String} filename - Filename of audio file to load\r\n     *  @param {Number} [randomness] - How much to randomize frequency each time sound plays\r\n     *  @param {Number} [range=soundDefaultRange] - World space max range of sound, will not play if camera is farther away\r\n     *  @param {Number} [taper=soundDefaultTaper] - At what percentage of range should it start tapering off\r\n     *  @param {Function} [onloadCallback] - callback function to call when sound is loaded\r\n     */\r\n    constructor(filename, randomness=0, range, taper, onloadCallback)\r\n    {\r\n        super(undefined, range, taper);\r\n        if (!soundEnable || headlessMode) return;\r\n\r\n        this.randomness = randomness;\r\n        fetch(filename)\r\n        .then(response => response.arrayBuffer())\r\n        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))\r\n        .then(audioBuffer => \r\n        {\r\n            this.sampleChannels = [];\r\n            for (let i = audioBuffer.numberOfChannels; i--;)\r\n                this.sampleChannels[i] = Array.from(audioBuffer.getChannelData(i));\r\n            this.sampleRate = audioBuffer.sampleRate;\r\n        }).then(() => onloadCallback && onloadCallback(this));\r\n    }\r\n}\r\n\r\n/** Play an mp3, ogg, or wav audio from a local file or url\r\n *  @param {String}  filename - Location of sound file to play\r\n *  @param {Number}  [volume] - How much to scale volume by\r\n *  @param {Boolean} [loop] - True if the music should loop\r\n *  @return {SoundWave} - The sound object for this file\r\n *  @memberof Audio */\r\nfunction playAudioFile(filename, volume=1, loop=false)\r\n{\r\n    if (!soundEnable || headlessMode) return;\r\n\r\n    return new SoundWave(filename,0,0,0, s=>s.play(undefined, volume, 1, 1, loop));\r\n}\r\n\r\n/**\r\n * Music Object - Stores a zzfx music track for later use\r\n * \r\n * <a href=https://keithclark.github.io/ZzFXM/>Create music with the ZzFXM tracker.</a>\r\n * @example\r\n * // create some music\r\n * const music_example = new Music(\r\n * [\r\n *     [                         // instruments\r\n *       [,0,400]                // simple note\r\n *     ], \r\n *     [                         // patterns\r\n *         [                     // pattern 1\r\n *             [                 // channel 0\r\n *                 0, -1,        // instrument 0, left speaker\r\n *                 1, 0, 9, 1    // channel notes\r\n *             ], \r\n *             [                 // channel 1\r\n *                 0, 1,         // instrument 0, right speaker\r\n *                 0, 12, 17, -1 // channel notes\r\n *             ]\r\n *         ],\r\n *     ],\r\n *     [0, 0, 0, 0], // sequence, play pattern 0 four times\r\n *     90            // BPM\r\n * ]);\r\n * \r\n * // play the music\r\n * music_example.play();\r\n */\r\nclass Music extends Sound\r\n{\r\n    /** Create a music object and cache the zzfx music samples for later use\r\n     *  @param {[Array, Array, Array, Number]} zzfxMusic - Array of zzfx music parameters\r\n     */\r\n    constructor(zzfxMusic)\r\n    {\r\n        super(undefined);\r\n\r\n        if (!soundEnable || headlessMode) return;\r\n        this.randomness = 0;\r\n        this.sampleChannels = zzfxM(...zzfxMusic);\r\n        this.sampleRate = zzfxR;\r\n    }\r\n\r\n    /** Play the music\r\n     *  @param {Number}  [volume=1] - How much to scale volume by\r\n     *  @param {Boolean} [loop] - True if the music should loop\r\n     *  @return {AudioBufferSourceNode} - The audio source node\r\n     */\r\n    playMusic(volume, loop=false)\r\n    { return super.play(undefined, volume, 1, 1, loop); }\r\n}\r\n\r\n/** Speak text with passed in settings\r\n *  @param {String} text - The text to speak\r\n *  @param {String} [language] - The language/accent to use (examples: en, it, ru, ja, zh)\r\n *  @param {Number} [volume] - How much to scale volume by\r\n *  @param {Number} [rate] - How quickly to speak\r\n *  @param {Number} [pitch] - How much to change the pitch by\r\n *  @return {SpeechSynthesisUtterance} - The utterance that was spoken\r\n *  @memberof Audio */\r\nfunction speak(text, language='', volume=1, rate=1, pitch=1)\r\n{\r\n    if (!soundEnable || headlessMode) return;\r\n    if (!speechSynthesis) return;\r\n\r\n    // common languages (not supported by all browsers)\r\n    // en - english,  it - italian, fr - french,  de - german, es - spanish\r\n    // ja - japanese, ru - russian, zh - chinese, hi - hindi,  ko - korean\r\n\r\n    // build utterance and speak\r\n    const utterance = new SpeechSynthesisUtterance(text);\r\n    utterance.lang = language;\r\n    utterance.volume = 2*volume*soundVolume;\r\n    utterance.rate = rate;\r\n    utterance.pitch = pitch;\r\n    speechSynthesis.speak(utterance);\r\n    return utterance;\r\n}\r\n\r\n/** Stop all queued speech\r\n *  @memberof Audio */\r\nfunction speakStop() {speechSynthesis && speechSynthesis.cancel();}\r\n\r\n/** Get frequency of a note on a musical scale\r\n *  @param {Number} semitoneOffset - How many semitones away from the root note\r\n *  @param {Number} [rootFrequency=220] - Frequency at semitone offset 0\r\n *  @return {Number} - The frequency of the note\r\n *  @memberof Audio */\r\nfunction getNoteFrequency(semitoneOffset, rootFrequency=220)\r\n{ return rootFrequency * 2**(semitoneOffset/12); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Play cached audio samples with given settings\r\n *  @param {Array}    sampleChannels - Array of arrays of samples to play (for stereo playback)\r\n *  @param {Number}   [volume] - How much to scale volume by\r\n *  @param {Number}   [rate] - The playback rate to use\r\n *  @param {Number}   [pan] - How much to apply stereo panning\r\n *  @param {Boolean}  [loop] - True if the sound should loop when it reaches the end\r\n *  @param {Number}   [sampleRate=44100] - Sample rate for the sound\r\n *  @param {GainNode} [gainNode] - Optional gain node for volume control while playing\r\n *  @return {AudioBufferSourceNode} - The audio node of the sound played\r\n *  @memberof Audio */\r\nfunction playSamples(sampleChannels, volume=1, rate=1, pan=0, loop=false, sampleRate=zzfxR, gainNode) \r\n{\r\n    if (!soundEnable || headlessMode) return;\r\n\r\n    // prevent sounds from building up if they can't be played\r\n    if (audioContext.state != 'running')\r\n    {\r\n        // fix stalled audio\r\n        audioContext.resume().then(()=>\r\n            playSamples(sampleChannels, volume, rate, pan, loop, sampleRate, gainNode));\r\n\r\n        // prevent suspended sounds from building up\r\n        return;\r\n    }\r\n\r\n    // create buffer and source\r\n    const channelCount = sampleChannels.length;\r\n    const sampleLength = sampleChannels[0].length;\r\n    const buffer = audioContext.createBuffer(channelCount, sampleLength, sampleRate);\r\n    const source = audioContext.createBufferSource();\r\n\r\n    // copy samples to buffer and setup source\r\n    sampleChannels.forEach((c,i)=> buffer.getChannelData(i).set(c));\r\n    source.buffer = buffer;\r\n    source.playbackRate.value = rate;\r\n    source.loop = loop;\r\n\r\n    // create and connect gain node\r\n    gainNode = gainNode || audioContext.createGain();\r\n    gainNode.gain.value = volume;\r\n    gainNode.connect(audioGainNode);\r\n\r\n    // connect source to stereo panner and gain\r\n    const pannerNode = new StereoPannerNode(audioContext, {'pan':clamp(pan, -1, 1)});\r\n    source.connect(pannerNode).connect(gainNode);\r\n\r\n    // play and return sound\r\n    source.start();\r\n    return source;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// ZzFXMicro - Zuper Zmall Zound Zynth - v1.3.1 by Frank Force\r\n\r\n/** Generate and play a ZzFX sound\r\n *  \r\n *  <a href=https://killedbyapixel.github.io/ZzFX/>Create sounds using the ZzFX Sound Designer.</a>\r\n *  @param {Array} zzfxSound - Array of ZzFX parameters, ex. [.5,.5]\r\n *  @return {AudioBufferSourceNode} - The audio node of the sound played\r\n *  @memberof Audio */\r\nfunction zzfx(...zzfxSound) { return playSamples([zzfxG(...zzfxSound)]); }\r\n\r\n/** Sample rate used for all ZzFX sounds\r\n *  @default 44100\r\n *  @memberof Audio */\r\nconst zzfxR = 44100; \r\n\r\n/** Generate samples for a ZzFX sound\r\n *  @param {Number}  [volume] - Volume scale (percent)\r\n *  @param {Number}  [randomness] - How much to randomize frequency (percent Hz)\r\n *  @param {Number}  [frequency] - Frequency of sound (Hz)\r\n *  @param {Number}  [attack] - Attack time, how fast sound starts (seconds)\r\n *  @param {Number}  [sustain] - Sustain time, how long sound holds (seconds)\r\n *  @param {Number}  [release] - Release time, how fast sound fades out (seconds)\r\n *  @param {Number}  [shape] - Shape of the sound wave\r\n *  @param {Number}  [shapeCurve] - Squarenes of wave (0=square, 1=normal, 2=pointy)\r\n *  @param {Number}  [slide] - How much to slide frequency (kHz/s)\r\n *  @param {Number}  [deltaSlide] - How much to change slide (kHz/s/s)\r\n *  @param {Number}  [pitchJump] - Frequency of pitch jump (Hz)\r\n *  @param {Number}  [pitchJumpTime] - Time of pitch jump (seconds)\r\n *  @param {Number}  [repeatTime] - Resets some parameters periodically (seconds)\r\n *  @param {Number}  [noise] - How much random noise to add (percent)\r\n *  @param {Number}  [modulation] - Frequency of modulation wave, negative flips phase (Hz)\r\n *  @param {Number}  [bitCrush] - Resamples at a lower frequency in (samples*100)\r\n *  @param {Number}  [delay] - Overlap sound with itself for reverb and flanger effects (seconds)\r\n *  @param {Number}  [sustainVolume] - Volume level for sustain (percent)\r\n *  @param {Number}  [decay] - Decay time, how long to reach sustain after attack (seconds)\r\n *  @param {Number}  [tremolo] - Trembling effect, rate controlled by repeat time (precent)\r\n *  @param {Number}  [filter] - Filter cutoff frequency, positive for HPF, negative for LPF (Hz)\r\n *  @return {Array} - Array of audio samples\r\n *  @memberof Audio\r\n */\r\nfunction zzfxG\r\n(\r\n    // parameters\r\n    volume = 1, randomness = .05, frequency = 220, attack = 0, sustain = 0,\r\n    release = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0,\r\n    pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0,\r\n    bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, tremolo = 0, filter = 0\r\n)\r\n{\r\n    // LJS Note: ZZFX modded so randomness is handled by Sound class\r\n\r\n    // init parameters\r\n    let PI2 = PI*2, sampleRate = zzfxR,\r\n        startSlide = slide *= 500 * PI2 / sampleRate / sampleRate,\r\n        startFrequency = frequency *= \r\n            rand(1 + randomness, 1-randomness) * PI2 / sampleRate,\r\n        b = [], t = 0, tm = 0, i = 0, j = 1, r = 0, c = 0, s = 0, f, length,\r\n\r\n        // biquad LP/HP filter\r\n        quality = 2, w = PI2 * abs(filter) * 2 / sampleRate,\r\n        cos = Math.cos(w), alpha = Math.sin(w) / 2 / quality,\r\n        a0 = 1 + alpha, a1 = -2*cos / a0, a2 = (1 - alpha) / a0,\r\n        b0 = (1 + sign(filter) * cos) / 2 / a0, \r\n        b1 = -(sign(filter) + cos) / a0, b2 = b0,\r\n        x2 = 0, x1 = 0, y2 = 0, y1 = 0;\r\n\r\n    // scale by sample rate\r\n    attack = attack * sampleRate + 9; // minimum attack to prevent pop\r\n    decay *= sampleRate;\r\n    sustain *= sampleRate;\r\n    release *= sampleRate;\r\n    delay *= sampleRate;\r\n    deltaSlide *= 500 * PI2 / sampleRate**3;\r\n    modulation *= PI2 / sampleRate;\r\n    pitchJump *= PI2 / sampleRate;\r\n    pitchJumpTime *= sampleRate;\r\n    repeatTime = repeatTime * sampleRate | 0;\r\n\r\n    // generate waveform\r\n    for(length = attack + decay + sustain + release + delay | 0;\r\n        i < length; b[i++] = s * volume)               // sample\r\n    {\r\n        if (!(++c%(bitCrush*100|0)))                   // bit crush\r\n        {\r\n            s = shape? shape>1? shape>2? shape>3?      // wave shape\r\n                Math.sin(t**3) :                       // 4 noise\r\n                clamp(Math.tan(t),1,-1):               // 3 tan\r\n                1-(2*t/PI2%2+2)%2:                     // 2 saw\r\n                1-4*abs(Math.round(t/PI2)-t/PI2):      // 1 triangle\r\n                Math.sin(t);                           // 0 sin\r\n\r\n            s = (repeatTime ?\r\n                    1 - tremolo + tremolo*Math.sin(PI2*i/repeatTime) // tremolo\r\n                    : 1) *\r\n                sign(s)*(abs(s)**shapeCurve) *           // curve\r\n                (i < attack ? i/attack :                 // attack\r\n                i < attack + decay ?                     // decay\r\n                1-((i-attack)/decay)*(1-sustainVolume) : // decay falloff\r\n                i < attack  + decay + sustain ?          // sustain\r\n                sustainVolume :                          // sustain volume\r\n                i < length - delay ?                     // release\r\n                (length - i - delay)/release *           // release falloff\r\n                sustainVolume :                          // release volume\r\n                0);                                      // post release\r\n\r\n            s = delay ? s/2 + (delay > i ? 0 :           // delay\r\n                (i<length-delay? 1 : (length-i)/delay) * // release delay \r\n                b[i-delay|0]/2/volume) : s;              // sample delay\r\n\r\n            if (filter)                                   // apply filter\r\n                s = y1 = b2*x2 + b1*(x2=x1) + b0*(x1=s) - a2*y2 - a1*(y2=y1);\r\n        }\r\n\r\n        f = (frequency += slide += deltaSlide) *// frequency\r\n            Math.cos(modulation*tm++);          // modulation\r\n        t += f + f*noise*Math.sin(i**5);        // noise\r\n\r\n        if (j && ++j > pitchJumpTime)           // pitch jump\r\n        { \r\n            frequency += pitchJump;             // apply pitch jump\r\n            startFrequency += pitchJump;        // also apply to start\r\n            j = 0;                              // stop pitch jump time\r\n        } \r\n\r\n        if (repeatTime && !(++r % repeatTime))  // repeat\r\n        { \r\n            frequency = startFrequency;         // reset frequency\r\n            slide = startSlide;                 // reset slide\r\n            j = j || 1;                         // reset pitch jump time\r\n        }\r\n    }\r\n\r\n    return b;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// ZzFX Music Renderer v2.0.3 by Keith Clark and Frank Force\r\n\r\n/** Generate samples for a ZzFM song with given parameters\r\n *  @param {Array} instruments - Array of ZzFX sound paramaters\r\n *  @param {Array} patterns - Array of pattern data\r\n *  @param {Array} sequence - Array of pattern indexes\r\n *  @param {Number} [BPM] - Playback speed of the song in BPM\r\n *  @return {Array} - Left and right channel sample data\r\n *  @memberof Audio */\r\nfunction zzfxM(instruments, patterns, sequence, BPM = 125) \r\n{\r\n  let i, j, k;\r\n  let instrumentParameters;\r\n  let note;\r\n  let sample;\r\n  let patternChannel;\r\n  let notFirstBeat;\r\n  let stop;\r\n  let instrument;\r\n  let attenuation;\r\n  let outSampleOffset;\r\n  let isSequenceEnd;\r\n  let sampleOffset = 0;\r\n  let nextSampleOffset;\r\n  let sampleBuffer = [];\r\n  let leftChannelBuffer = [];\r\n  let rightChannelBuffer = [];\r\n  let channelIndex = 0;\r\n  let panning = 0;\r\n  let hasMore = 1;\r\n  let sampleCache = {};\r\n  let beatLength = zzfxR / BPM * 60 >> 2;\r\n\r\n  // for each channel in order until there are no more\r\n  for (; hasMore; channelIndex++) {\r\n\r\n    // reset current values\r\n    sampleBuffer = [hasMore = notFirstBeat = outSampleOffset = 0];\r\n\r\n    // for each pattern in sequence\r\n    sequence.forEach((patternIndex, sequenceIndex) => {\r\n      // get pattern for current channel, use empty 1 note pattern if none found\r\n      patternChannel = patterns[patternIndex][channelIndex] || [0, 0, 0];\r\n\r\n      // check if there are more channels\r\n      hasMore |= patterns[patternIndex][channelIndex]&&1;\r\n\r\n      // get next offset, use the length of first channel\r\n      nextSampleOffset = outSampleOffset + (patterns[patternIndex][0].length - 2 - (notFirstBeat?0:1)) * beatLength;\r\n      // for each beat in pattern, plus one extra if end of sequence\r\n      isSequenceEnd = sequenceIndex == sequence.length - 1;\r\n      for (i = 2, k = outSampleOffset; i < patternChannel.length + isSequenceEnd; notFirstBeat = ++i) {\r\n\r\n        // <channel-note>\r\n        note = patternChannel[i];\r\n\r\n        // stop if end, different instrument or new note\r\n        stop = i == patternChannel.length + isSequenceEnd - 1 && isSequenceEnd ||\r\n            instrument != (patternChannel[0] || 0) || note | 0;\r\n\r\n        // fill buffer with samples for previous beat, most cpu intensive part\r\n        for (j = 0; j < beatLength && notFirstBeat;\r\n\r\n            // fade off attenuation at end of beat if stopping note, prevents clicking\r\n            j++ > beatLength - 99 && stop && attenuation < 1? attenuation += 1 / 99 : 0\r\n        ) {\r\n          // copy sample to stereo buffers with panning\r\n          sample = (1 - attenuation) * sampleBuffer[sampleOffset++] / 2 || 0;\r\n          leftChannelBuffer[k] = (leftChannelBuffer[k] || 0) - sample * panning + sample;\r\n          rightChannelBuffer[k] = (rightChannelBuffer[k++] || 0) + sample * panning + sample;\r\n        }\r\n\r\n        // set up for next note\r\n        if (note) {\r\n          // set attenuation\r\n          attenuation = note % 1;\r\n          panning = patternChannel[1] || 0;\r\n          if (note |= 0) {\r\n            // get cached sample\r\n            sampleBuffer = sampleCache[\r\n              [\r\n                instrument = patternChannel[sampleOffset = 0] || 0,\r\n                note\r\n              ]\r\n            ] = sampleCache[[instrument, note]] || (\r\n                // add sample to cache\r\n                instrumentParameters = [...instruments[instrument]],\r\n                instrumentParameters[2] *= 2 ** ((note - 12) / 12),\r\n\r\n                // allow negative values to stop notes\r\n                note > 0 ? zzfxG(...instrumentParameters) : []\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // update the sample offset\r\n      outSampleOffset = nextSampleOffset;\r\n    });\r\n  }\r\n\r\n  return [leftChannelBuffer, rightChannelBuffer];\r\n}\n/** \r\n * LittleJS Tile Layer System\r\n * - Caches arrays of tiles to off screen canvas for fast rendering\r\n * - Unlimited numbers of layers, allocates canvases as needed\r\n * - Interfaces with EngineObject for collision\r\n * - Collision layer is separate from visible layers\r\n * - It is recommended to have a visible layer that matches the collision\r\n * - Tile layers can be drawn to using their context with canvas2d\r\n * - Drawn directly to the main canvas without using WebGL\r\n * @namespace TileCollision\r\n */\r\n\r\n\r\n\r\n/** The tile collision layer array, use setTileCollisionData and getTileCollisionData to access\r\n *  @type {Array} \r\n *  @memberof TileCollision */\r\nlet tileCollision = [];\r\n\r\n/** Size of the tile collision layer\r\n *  @type {Vector2} \r\n *  @memberof TileCollision */\r\nlet tileCollisionSize = vec2();\r\n\r\n/** Clear and initialize tile collision\r\n *  @param {Vector2} size\r\n *  @memberof TileCollision */\r\nfunction initTileCollision(size)\r\n{\r\n    tileCollisionSize = size;\r\n    tileCollision = [];\r\n    for (let i=tileCollision.length = tileCollisionSize.area(); i--;)\r\n        tileCollision[i] = 0;\r\n}\r\n\r\n/** Set tile collision data\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [data]\r\n *  @memberof TileCollision */\r\nfunction setTileCollisionData(pos, data=0)\r\n{\r\n    pos.arrayCheck(tileCollisionSize) && (tileCollision[(pos.y|0)*tileCollisionSize.x+pos.x|0] = data);\r\n}\r\n\r\n/** Get tile collision data\r\n *  @param {Vector2} pos\r\n *  @return {Number}\r\n *  @memberof TileCollision */\r\nfunction getTileCollisionData(pos)\r\n{\r\n    return pos.arrayCheck(tileCollisionSize) ? tileCollision[(pos.y|0)*tileCollisionSize.x+pos.x|0] : 0;\r\n}\r\n\r\n/** Check if collision with another object should occur\r\n *  @param {Vector2}      pos\r\n *  @param {Vector2}      [size=(0,0)]\r\n *  @param {EngineObject} [object]\r\n *  @return {Boolean}\r\n *  @memberof TileCollision */\r\nfunction tileCollisionTest(pos, size=vec2(), object)\r\n{\r\n    const minX = max(pos.x - size.x/2|0, 0);\r\n    const minY = max(pos.y - size.y/2|0, 0);\r\n    const maxX = min(pos.x + size.x/2, tileCollisionSize.x);\r\n    const maxY = min(pos.y + size.y/2, tileCollisionSize.y);\r\n    for (let y = minY; y < maxY; ++y)\r\n    for (let x = minX; x < maxX; ++x)\r\n    {\r\n        const tileData = tileCollision[y*tileCollisionSize.x+x];\r\n        if (tileData && (!object || object.collideWithTile(tileData, vec2(x, y))))\r\n            return true;\r\n    }\r\n}\r\n\r\n/** Return the center of first tile hit (does not return the exact intersection)\r\n *  @param {Vector2}      posStart\r\n *  @param {Vector2}      posEnd\r\n *  @param {EngineObject} [object]\r\n *  @return {Vector2}\r\n *  @memberof TileCollision */\r\nfunction tileCollisionRaycast(posStart, posEnd, object)\r\n{\r\n    // test if a ray collides with tiles from start to end\r\n    // todo: a way to get the exact hit point, it must still be inside the hit tile\r\n    const delta = posEnd.subtract(posStart);\r\n    const totalLength = delta.length();\r\n    const normalizedDelta = delta.normalize();\r\n    const unit = vec2(abs(1/normalizedDelta.x), abs(1/normalizedDelta.y));\r\n    const flooredPosStart = posStart.floor();\r\n\r\n    // setup iteration variables\r\n    let pos = flooredPosStart;\r\n    let xi = unit.x * (delta.x < 0 ? posStart.x - pos.x : pos.x - posStart.x + 1);\r\n    let yi = unit.y * (delta.y < 0 ? posStart.y - pos.y : pos.y - posStart.y + 1);\r\n\r\n    while (1)\r\n    {\r\n        // check for tile collision\r\n        const tileData = getTileCollisionData(pos);\r\n        if (tileData && (!object || object.collideWithTile(tileData, pos)))\r\n        {\r\n            debugRaycast && debugLine(posStart, posEnd, '#f00', .02);\r\n            debugRaycast && debugPoint(pos.add(vec2(.5)), '#ff0');\r\n            return pos.add(vec2(.5));\r\n        }\r\n\r\n        // check if past the end\r\n        if (xi > totalLength && yi > totalLength)\r\n            break;\r\n\r\n        // get coordinates of the next tile to check\r\n        if (xi > yi)\r\n            pos.y += sign(delta.y), yi += unit.y;\r\n        else\r\n            pos.x += sign(delta.x), xi += unit.x;\r\n    }\r\n\r\n    debugRaycast && debugLine(posStart, posEnd, '#00f', .02);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Tile Layer Rendering System\r\n\r\n/**\r\n * Tile layer data object stores info about how to render a tile\r\n * @example\r\n * // create tile layer data with tile index 0 and random orientation and color\r\n * const tileIndex = 0;\r\n * const direction = randInt(4)\r\n * const mirror = randInt(2);\r\n * const color = randColor();\r\n * const data = new TileLayerData(tileIndex, direction, mirror, color);\r\n */\r\nclass TileLayerData\r\n{\r\n    /** Create a tile layer data object, one for each tile in a TileLayer\r\n     *  @param {Number}  [tile]      - The tile to use, untextured if undefined\r\n     *  @param {Number}  [direction] - Integer direction of tile, in 90 degree increments\r\n     *  @param {Boolean} [mirror]    - If the tile should be mirrored along the x axis\r\n     *  @param {Color}   [color]     - Color of the tile */\r\n    constructor(tile, direction=0, mirror=false, color=new Color)\r\n    {\r\n        /** @property {Number}  - The tile to use, untextured if undefined */\r\n        this.tile      = tile;\r\n        /** @property {Number}  - Integer direction of tile, in 90 degree increments */\r\n        this.direction = direction;\r\n        /** @property {Boolean} - If the tile should be mirrored along the x axis */\r\n        this.mirror    = mirror;\r\n        /** @property {Color}   - Color of the tile */\r\n        this.color     = color;\r\n    }\r\n\r\n    /** Set this tile to clear, it will not be rendered */\r\n    clear() { this.tile = this.direction = 0; this.mirror = false; this.color = new Color; }\r\n}\r\n\r\n/**\r\n * Tile Layer - cached rendering system for tile layers\r\n * - Each Tile layer is rendered to an off screen canvas\r\n * - To allow dynamic modifications, layers are rendered using canvas 2d\r\n * - Some devices like mobile phones are limited to 4k texture resolution\r\n * - So with 16x16 tiles this limits layers to 256x256 on mobile devices\r\n * @extends EngineObject\r\n * @example\r\n * // create tile collision and visible tile layer\r\n * initTileCollision(vec2(200,100));\r\n * const tileLayer = new TileLayer();\r\n */\r\nclass TileLayer extends EngineObject\r\n{\r\n    /** Create a tile layer object\r\n    *  @param {Vector2}  [position=(0,0)]     - World space position\r\n    *  @param {Vector2}  [size=tileCollisionSize] - World space size\r\n    *  @param {TileInfo} [tileInfo]    - Tile info for layer\r\n    *  @param {Vector2}  [scale=(1,1)] - How much to scale this layer when rendered\r\n    *  @param {Number}   [renderOrder] - Objects are sorted by renderOrder\r\n    */\r\n    constructor(position, size=tileCollisionSize, tileInfo=tile(), scale=vec2(1), renderOrder=0)\r\n    {\r\n        super(position, size, tileInfo, 0, undefined, renderOrder);\r\n\r\n        /** @property {HTMLCanvasElement} - The canvas used by this tile layer */\r\n        this.canvas = document.createElement('canvas');\r\n        /** @property {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} - The 2D canvas context used by this tile layer */\r\n        this.context = this.canvas.getContext('2d');\r\n        /** @property {Vector2} - How much to scale this layer when rendered */\r\n        this.scale = scale;\r\n        /** @property {Boolean} - If true this layer will render to overlay canvas and appear above all objects */\r\n        this.isOverlay = false;\r\n\r\n        // init tile data\r\n        this.data = [];\r\n        for (let j = this.size.area(); j--;)\r\n            this.data.push(new TileLayerData);\r\n\r\n        if (headlessMode)\r\n        {\r\n            // disable rendering\r\n            this.redraw       = () => {};\r\n            this.render       = () => {};\r\n            this.redrawStart  = () => {};\r\n            this.redrawEnd    = () => {};\r\n            this.drawTileData = () => {};\r\n            this.drawCanvas2D = () => {};\r\n        }\r\n    }\r\n    \r\n    /** Set data at a given position in the array \r\n     *  @param {Vector2}       layerPos - Local position in array\r\n     *  @param {TileLayerData} data     - Data to set\r\n     *  @param {Boolean}       [redraw] - Force the tile to redraw if true */\r\n    setData(layerPos, data, redraw=false)\r\n    {\r\n        if (layerPos.arrayCheck(this.size))\r\n        {\r\n            this.data[(layerPos.y|0)*this.size.x+layerPos.x|0] = data;\r\n            redraw && this.drawTileData(layerPos);\r\n        }\r\n    }\r\n    \r\n    /** Get data at a given position in the array \r\n     *  @param {Vector2} layerPos - Local position in array\r\n     *  @return {TileLayerData} */\r\n    getData(layerPos)\r\n    { return layerPos.arrayCheck(this.size) && this.data[(layerPos.y|0)*this.size.x+layerPos.x|0]; }\r\n    \r\n    // Tile layers are not updated\r\n    update() {}\r\n\r\n    // Render the tile layer, called automatically by the engine\r\n    render()\r\n    {\r\n        ASSERT(mainContext != this.context, 'must call redrawEnd() after drawing tiles');\r\n\r\n        // flush and copy gl canvas because tile canvas does not use webgl\r\n        !glOverlay && !this.isOverlay && glCopyToContext(mainContext);\r\n        \r\n        // draw the entire cached level onto the canvas\r\n        const pos = worldToScreen(this.pos.add(vec2(0,this.size.y*this.scale.y)));\r\n        (this.isOverlay ? overlayContext : mainContext).drawImage\r\n        (\r\n            this.canvas, pos.x, pos.y,\r\n            cameraScale*this.size.x*this.scale.x, cameraScale*this.size.y*this.scale.y\r\n        );\r\n    }\r\n\r\n    /** Draw all the tile data to an offscreen canvas \r\n     *  - This may be slow in some browsers but only needs to be done once */\r\n    redraw()\r\n    {\r\n        this.redrawStart(true);\r\n        for (let x = this.size.x; x--;)\r\n        for (let y = this.size.y; y--;)\r\n            this.drawTileData(vec2(x,y), false);\r\n        this.redrawEnd();\r\n    }\r\n\r\n    /** Call to start the redraw process\r\n     *  - This can be used to manually update small parts of the level\r\n     *  @param {Boolean} [clear] - Should it clear the canvas before drawing */\r\n    redrawStart(clear=false)\r\n    {\r\n        // save current render settings\r\n        /** @type {[HTMLCanvasElement, CanvasRenderingContext2D, Vector2, Vector2, number]} */\r\n        this.savedRenderSettings = [mainCanvas, mainContext, mainCanvasSize, cameraPos, cameraScale];\r\n\r\n        // use webgl rendering system to render the tiles if enabled\r\n        // this works by temporally taking control of the rendering system\r\n        mainCanvas = this.canvas;\r\n        mainContext = this.context;\r\n        mainCanvasSize = this.size.multiply(this.tileInfo.size);\r\n        cameraPos = this.size.scale(.5);\r\n        cameraScale = this.tileInfo.size.x;\r\n\r\n        if (clear)\r\n        {\r\n            // clear and set size\r\n            mainCanvas.width  = mainCanvasSize.x;\r\n            mainCanvas.height = mainCanvasSize.y;\r\n        }\r\n\r\n        // disable smoothing for pixel art\r\n        this.context.imageSmoothingEnabled = !canvasPixelated;\r\n\r\n        // setup gl rendering if enabled\r\n        glPreRender();\r\n    }\r\n\r\n    /** Call to end the redraw process */\r\n    redrawEnd()\r\n    {\r\n        ASSERT(mainContext == this.context, 'must call redrawStart() before drawing tiles');\r\n        glCopyToContext(mainContext, true);\r\n        //debugSaveCanvas(this.canvas);\r\n\r\n        // set stuff back to normal\r\n        [mainCanvas, mainContext, mainCanvasSize, cameraPos, cameraScale] = this.savedRenderSettings;\r\n    }\r\n\r\n    /** Draw the tile at a given position in the tile grid\r\n     *  This can be used to clear out tiles when they are destroyed\r\n     *  Tiles can also be redrawn if isinde a redrawStart/End block\r\n     *  @param {Vector2} layerPos \r\n     *  @param {Boolean} [clear] - should the old tile be cleared out\r\n     */\r\n    drawTileData(layerPos, clear=true)\r\n    {\r\n        // clear out where the tile was, for full opaque tiles this can be skipped\r\n        const s = this.tileInfo.size;\r\n        if (clear)\r\n        {\r\n            const pos = layerPos.multiply(s);\r\n            this.context.clearRect(pos.x, this.canvas.height-pos.y, s.x, -s.y);\r\n        }\r\n\r\n        // draw the tile if not undefined\r\n        const d = this.getData(layerPos);\r\n        if (d.tile != undefined)\r\n        {\r\n            const pos = this.pos.add(layerPos).add(vec2(.5));\r\n            ASSERT(mainContext == this.context, 'must call redrawStart() before drawing tiles');\r\n            const tileInfo = tile(d.tile, s, this.tileInfo.textureIndex);\r\n            drawTile(pos, vec2(1), tileInfo, d.color, d.direction*PI/2, d.mirror);\r\n        }\r\n    }\r\n\r\n    /** Draw directly to the 2D canvas in world space (bipass webgl)\r\n     *  @param {Vector2}  pos\r\n     *  @param {Vector2}  size\r\n     *  @param {Number}   angle\r\n     *  @param {Boolean}  mirror\r\n     *  @param {Function} drawFunction */\r\n    drawCanvas2D(pos, size, angle, mirror, drawFunction)\r\n    {\r\n        const context = this.context;\r\n        context.save();\r\n        pos = pos.subtract(this.pos).multiply(this.tileInfo.size);\r\n        size = size.multiply(this.tileInfo.size);\r\n        context.translate(pos.x, this.canvas.height - pos.y);\r\n        context.rotate(angle);\r\n        context.scale(mirror ? -size.x : size.x, size.y);\r\n        drawFunction(context);\r\n        context.restore();\r\n    }\r\n\r\n    /** Draw a tile directly onto the layer canvas in world space\r\n     *  @param {Vector2}  pos\r\n     *  @param {Vector2}  [size=(1,1)]\r\n     *  @param {TileInfo} [tileInfo]\r\n     *  @param {Color}    [color=(1,1,1,1)]\r\n     *  @param {Number}   [angle=0]\r\n     *  @param {Boolean}  [mirror=0] */\r\n    drawTile(pos, size=vec2(1), tileInfo, color=new Color, angle, mirror)\r\n    {\r\n        this.drawCanvas2D(pos, size, angle, mirror, (context)=>\r\n        {\r\n            const textureInfo = tileInfo && tileInfo.getTextureInfo();\r\n            if (textureInfo)\r\n            {\r\n                context.globalAlpha = color.a; // only alpha is supported\r\n                context.drawImage(textureInfo.image, \r\n                    tileInfo.pos.x,  tileInfo.pos.y, \r\n                    tileInfo.size.x, tileInfo.size.y, -.5, -.5, 1, 1);\r\n                context.globalAlpha = 1;\r\n            }\r\n            else\r\n            {\r\n                // untextured\r\n                context.fillStyle = color;\r\n                context.fillRect(-.5, -.5, 1, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Draw a rectangle directly onto the layer canvas in world space\r\n     *  @param {Vector2} pos\r\n     *  @param {Vector2} [size=(1,1)]\r\n     *  @param {Color}   [color=(1,1,1,1)]\r\n     *  @param {Number}  [angle=0] */\r\n    drawRect(pos, size, color, angle) \r\n    { this.drawTile(pos, size, undefined, color, angle); }\r\n}\n/** \r\n * LittleJS Particle System\r\n */\r\n\r\n\r\n\r\n/**\r\n * Particle Emitter - Spawns particles with the given settings\r\n * @extends EngineObject\r\n * @example\r\n * // create a particle emitter\r\n * let pos = vec2(2,3);\r\n * let particleEmitter = new ParticleEmitter\r\n * (\r\n *     pos, 0, 1, 0, 500, PI,      // pos, angle, emitSize, emitTime, emitRate, emiteCone\r\n *     tile(0, 16),                // tileInfo\r\n *     rgb(1,1,1),   rgb(0,0,0),   // colorStartA, colorStartB\r\n *     rgb(1,1,1,0), rgb(0,0,0,0), // colorEndA, colorEndB\r\n *     2, .2, .2, .1, .05,  // particleTime, sizeStart, sizeEnd, particleSpeed, particleAngleSpeed\r\n *     .99, 1, 1, PI, .05,  // damping, angleDamping, gravityScale, particleCone, fadeRate, \r\n *     .5, 1                // randomness, collide, additive, randomColorLinear, renderOrder\r\n * );\r\n */\r\nclass ParticleEmitter extends EngineObject\r\n{\r\n    /** Create a particle system with the given settings\r\n     *  @param {Vector2} position - World space position of the emitter\r\n     *  @param {Number} [angle] - Angle to emit the particles\r\n     *  @param {Number|Vector2}  [emitSize] - World space size of the emitter (float for circle diameter, vec2 for rect)\r\n     *  @param {Number} [emitTime] - How long to stay alive (0 is forever)\r\n     *  @param {Number} [emitRate] - How many particles per second to spawn, does not emit if 0\r\n     *  @param {Number} [emitConeAngle=PI] - Local angle to apply velocity to particles from emitter\r\n     *  @param {TileInfo} [tileInfo] - Tile info to render particles (undefined is untextured)\r\n     *  @param {Color} [colorStartA=(1,1,1,1)] - Color at start of life 1, randomized between start colors\r\n     *  @param {Color} [colorStartB=(1,1,1,1)] - Color at start of life 2, randomized between start colors\r\n     *  @param {Color} [colorEndA=(1,1,1,0)] - Color at end of life 1, randomized between end colors\r\n     *  @param {Color} [colorEndB=(1,1,1,0)] - Color at end of life 2, randomized between end colors\r\n     *  @param {Number} [particleTime]      - How long particles live\r\n     *  @param {Number} [sizeStart]         - How big are particles at start\r\n     *  @param {Number} [sizeEnd]           - How big are particles at end\r\n     *  @param {Number} [speed]             - How fast are particles when spawned\r\n     *  @param {Number} [angleSpeed]        - How fast are particles rotating\r\n     *  @param {Number} [damping]           - How much to dampen particle speed\r\n     *  @param {Number} [angleDamping]      - How much to dampen particle angular speed\r\n     *  @param {Number} [gravityScale]      - How much gravity effect particles\r\n     *  @param {Number} [particleConeAngle] - Cone for start particle angle\r\n     *  @param {Number} [fadeRate]          - How quick to fade particles at start/end in percent of life\r\n     *  @param {Number} [randomness]    - Apply extra randomness percent\r\n     *  @param {Boolean} [collideTiles] - Do particles collide against tiles\r\n     *  @param {Boolean} [additive]     - Should particles use addtive blend\r\n     *  @param {Boolean} [randomColorLinear] - Should color be randomized linearly or across each component\r\n     *  @param {Number} [renderOrder] - Render order for particles (additive is above other stuff by default)\r\n     *  @param {Boolean}  [localSpace] - Should it be in local space of emitter (world space is default)\r\n     */\r\n    constructor\r\n    ( \r\n        position,\r\n        angle,\r\n        emitSize = 0,\r\n        emitTime = 0,\r\n        emitRate = 100,\r\n        emitConeAngle = PI,\r\n        tileInfo,\r\n        colorStartA = new Color,\r\n        colorStartB = new Color,\r\n        colorEndA = new Color(1,1,1,0),\r\n        colorEndB = new Color(1,1,1,0),\r\n        particleTime = .5,\r\n        sizeStart = .1,\r\n        sizeEnd = 1,\r\n        speed = .1,\r\n        angleSpeed = .05,\r\n        damping = 1,\r\n        angleDamping = 1,\r\n        gravityScale = 0,\r\n        particleConeAngle = PI,\r\n        fadeRate = .1,\r\n        randomness = .2, \r\n        collideTiles = false,\r\n        additive = false,\r\n        randomColorLinear = true,\r\n        renderOrder = additive ? 1e9 : 0,\r\n        localSpace = false\r\n    )\r\n    {\r\n        super(position, vec2(), tileInfo, angle, undefined, renderOrder);\r\n\r\n        // emitter settings\r\n        /** @property {Number|Vector2} - World space size of the emitter (float for circle diameter, vec2 for rect) */\r\n        this.emitSize = emitSize\r\n        /** @property {Number} - How long to stay alive (0 is forever) */\r\n        this.emitTime = emitTime;\r\n        /** @property {Number} - How many particles per second to spawn, does not emit if 0 */\r\n        this.emitRate = emitRate;\r\n        /** @property {Number} - Local angle to apply velocity to particles from emitter */\r\n        this.emitConeAngle = emitConeAngle;\r\n\r\n        // color settings\r\n        /** @property {Color} - Color at start of life 1, randomized between start colors */\r\n        this.colorStartA = colorStartA;\r\n        /** @property {Color} - Color at start of life 2, randomized between start colors */\r\n        this.colorStartB = colorStartB;\r\n        /** @property {Color} - Color at end of life 1, randomized between end colors */\r\n        this.colorEndA   = colorEndA;\r\n        /** @property {Color} - Color at end of life 2, randomized between end colors */\r\n        this.colorEndB   = colorEndB;\r\n        /** @property {Boolean} - Should color be randomized linearly or across each component */\r\n        this.randomColorLinear = randomColorLinear;\r\n\r\n        // particle settings\r\n        /** @property {Number} - How long particles live */\r\n        this.particleTime      = particleTime;\r\n        /** @property {Number} - How big are particles at start */\r\n        this.sizeStart         = sizeStart;\r\n        /** @property {Number} - How big are particles at end */\r\n        this.sizeEnd           = sizeEnd;\r\n        /** @property {Number} - How fast are particles when spawned */\r\n        this.speed             = speed;\r\n        /** @property {Number} - How fast are particles rotating */\r\n        this.angleSpeed        = angleSpeed;\r\n        /** @property {Number} - How much to dampen particle speed */\r\n        this.damping           = damping;\r\n        /** @property {Number} - How much to dampen particle angular speed */\r\n        this.angleDamping      = angleDamping;\r\n        /** @property {Number} - How much does gravity effect particles */\r\n        this.gravityScale      = gravityScale;\r\n        /** @property {Number} - Cone for start particle angle */\r\n        this.particleConeAngle = particleConeAngle;\r\n        /** @property {Number} - How quick to fade in particles at start/end in percent of life */\r\n        this.fadeRate          = fadeRate;\r\n        /** @property {Number} - Apply extra randomness percent */\r\n        this.randomness        = randomness;\r\n        /** @property {Boolean} - Do particles collide against tiles */\r\n        this.collideTiles      = collideTiles;\r\n        /** @property {Boolean} - Should particles use addtive blend */\r\n        this.additive          = additive;\r\n        /** @property {Boolean} - Should it be in local space of emitter */\r\n        this.localSpace        = localSpace;\r\n        /** @property {Number} - If non zero the partile is drawn as a trail, stretched in the drection of velocity */\r\n        this.trailScale        = 0;\r\n        /** @property {Function}   - Callback when particle is destroyed */\r\n        this.particleDestroyCallback = undefined;\r\n        /** @property {Function}   - Callback when particle is created */\r\n        this.particleCreateCallback = undefined;\r\n        /** @property {Number} - Track particle emit time */\r\n        this.emitTimeBuffer    = 0;\r\n    }\r\n    \r\n    /** Update the emitter to spawn particles, called automatically by engine once each frame */\r\n    update()\r\n    {\r\n        // only do default update to apply parent transforms\r\n        this.parent && super.update();\r\n\r\n        // update emitter\r\n        if (!this.emitTime || this.getAliveTime() <= this.emitTime)\r\n        {\r\n            // emit particles\r\n            if (this.emitRate * particleEmitRateScale)\r\n            {\r\n                const rate = 1/this.emitRate/particleEmitRateScale;\r\n                for (this.emitTimeBuffer += timeDelta; this.emitTimeBuffer > 0; this.emitTimeBuffer -= rate)\r\n                    this.emitParticle();\r\n            }\r\n        }\r\n        else\r\n            this.destroy();\r\n\r\n        debugParticles && debugRect(this.pos, vec2(this.emitSize), '#0f0', 0, this.angle);\r\n    }\r\n\r\n    /** Spawn one particle\r\n     *  @return {Particle} */\r\n    emitParticle()\r\n    {\r\n        // spawn a particle\r\n        let pos = typeof this.emitSize === 'number' ? // check if number was used\r\n            randInCircle(this.emitSize/2)              // circle emitter\r\n            : vec2(rand(-.5,.5), rand(-.5,.5))         // box emitter\r\n                .multiply(this.emitSize).rotate(this.angle)\r\n        let angle = rand(this.particleConeAngle, -this.particleConeAngle);\r\n        if (!this.localSpace)\r\n        {\r\n            pos = this.pos.add(pos);\r\n            angle += this.angle;\r\n        }\r\n\r\n        // randomness scales each paremeter by a percentage\r\n        const randomness = this.randomness;\r\n        const randomizeScale = (v)=> v + v*rand(randomness, -randomness);\r\n\r\n        // randomize particle settings\r\n        const particleTime  = randomizeScale(this.particleTime);\r\n        const sizeStart     = randomizeScale(this.sizeStart);\r\n        const sizeEnd       = randomizeScale(this.sizeEnd);\r\n        const speed         = randomizeScale(this.speed);\r\n        const angleSpeed    = randomizeScale(this.angleSpeed) * randSign();\r\n        const coneAngle     = rand(this.emitConeAngle, -this.emitConeAngle);\r\n        const colorStart    = randColor(this.colorStartA, this.colorStartB, this.randomColorLinear);\r\n        const colorEnd      = randColor(this.colorEndA,   this.colorEndB, this.randomColorLinear);\r\n        const velocityAngle = this.localSpace ? coneAngle : this.angle + coneAngle;\r\n        \r\n        // build particle\r\n        const particle = new Particle(pos, this.tileInfo, angle, colorStart, colorEnd, particleTime, sizeStart, sizeEnd, this.fadeRate, this.additive,  this.trailScale, this.localSpace && this, this.particleDestroyCallback);\r\n        particle.velocity      = vec2().setAngle(velocityAngle, speed);\r\n        particle.angleVelocity = angleSpeed;\r\n        particle.fadeRate      = this.fadeRate;\r\n        particle.damping       = this.damping;\r\n        particle.angleDamping  = this.angleDamping;\r\n        particle.elasticity    = this.elasticity;\r\n        particle.friction      = this.friction;\r\n        particle.gravityScale  = this.gravityScale;\r\n        particle.collideTiles  = this.collideTiles;\r\n        particle.renderOrder   = this.renderOrder;\r\n        particle.mirror        = !!randInt(2);\r\n\r\n        // call particle create callaback\r\n        this.particleCreateCallback && this.particleCreateCallback(particle);\r\n\r\n        // return the newly created particle\r\n        return particle;\r\n    }\r\n\r\n    // Particle emitters are not rendered, only the particles are\r\n    render() {}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Particle Object - Created automatically by Particle Emitters\r\n * @extends EngineObject\r\n */\r\nclass Particle extends EngineObject\r\n{\r\n    /**\r\n     * Create a particle with the passed in settings\r\n     * Typically this is created automatically by a ParticleEmitter\r\n     * @param {Vector2}  position   - World space position of the particle\r\n     * @param {TileInfo} tileInfo   - Tile info to render particles\r\n     * @param {Number}   angle      - Angle to rotate the particle\r\n     * @param {Color}    colorStart - Color at start of life\r\n     * @param {Color}    colorEnd   - Color at end of life\r\n     * @param {Number}   lifeTime   - How long to live for\r\n     * @param {Number}   sizeStart  - Size at start of life\r\n     * @param {Number}   sizeEnd    - Size at end of life\r\n     * @param {Number}   fadeRate   - How quick to fade in/out\r\n     * @param {Boolean}  additive   - Does it use additive blend mode\r\n     * @param {Number}   trailScale - If a trail, how long to make it\r\n     * @param {ParticleEmitter} [localSpaceEmitter] - Parent emitter if local space\r\n     * @param {Function} [destroyCallback] - Callback when particle dies\r\n     */\r\n    constructor(position, tileInfo, angle, colorStart, colorEnd, lifeTime, sizeStart, sizeEnd, fadeRate, additive, trailScale, localSpaceEmitter, destroyCallback\r\n    )\r\n    { \r\n        super(position, vec2(), tileInfo, angle); \r\n    \r\n        /** @property {Color} - Color at start of life */\r\n        this.colorStart = colorStart;\r\n        /** @property {Color} - Calculated change in color */\r\n        this.colorEndDelta = colorEnd.subtract(colorStart);\r\n        /** @property {Number} - How long to live for */\r\n        this.lifeTime = lifeTime;\r\n        /** @property {Number} - Size at start of life */\r\n        this.sizeStart = sizeStart;\r\n        /** @property {Number} - Calculated change in size */\r\n        this.sizeEndDelta = sizeEnd - sizeStart;\r\n        /** @property {Number} - How quick to fade in/out */\r\n        this.fadeRate = fadeRate;\r\n        /** @property {Boolean} - Is it additive */\r\n        this.additive = additive;\r\n        /** @property {Number} - If a trail, how long to make it */\r\n        this.trailScale = trailScale;\r\n        /** @property {ParticleEmitter} - Parent emitter if local space */\r\n        this.localSpaceEmitter = localSpaceEmitter;\r\n        /** @property {Function} - Called when particle dies */\r\n        this.destroyCallback = destroyCallback;\r\n\r\n        // particles use circular clamped speed\r\n        this.clampSpeedLinear = false;\r\n    }\r\n\r\n    /** Render the particle, automatically called each frame, sorted by renderOrder */\r\n    render()\r\n    {\r\n        // modulate size and color\r\n        const p = min((time - this.spawnTime) / this.lifeTime, 1);\r\n        const radius = this.sizeStart + p * this.sizeEndDelta;\r\n        const size = vec2(radius);\r\n        const fadeRate = this.fadeRate/2;\r\n        const color = new Color(\r\n            this.colorStart.r + p * this.colorEndDelta.r,\r\n            this.colorStart.g + p * this.colorEndDelta.g,\r\n            this.colorStart.b + p * this.colorEndDelta.b,\r\n            (this.colorStart.a + p * this.colorEndDelta.a) * \r\n             (p < fadeRate ? p/fadeRate : p > 1-fadeRate ? (1-p)/fadeRate : 1)); // fade alpha\r\n\r\n        // draw the particle\r\n        this.additive && setBlendMode(true);\r\n\r\n        let pos = this.pos, angle = this.angle;\r\n        if (this.localSpaceEmitter)\r\n        {\r\n            // in local space of emitter\r\n            pos = this.localSpaceEmitter.pos.add(pos.rotate(-this.localSpaceEmitter.angle)); \r\n            angle += this.localSpaceEmitter.angle;\r\n        }\r\n        if (this.trailScale)\r\n        {\r\n            // trail style particles\r\n            let velocity = this.velocity;\r\n            if (this.localSpaceEmitter)\r\n                velocity = velocity.rotate(-this.localSpaceEmitter.angle);\r\n            const speed = velocity.length();\r\n            if (speed)\r\n            {\r\n                const direction = velocity.scale(1/speed);\r\n                const trailLength = speed * this.trailScale;\r\n                size.y = max(size.x, trailLength);\r\n                angle = direction.angle();\r\n                drawTile(pos.add(direction.multiply(vec2(0,-trailLength/2))), size, this.tileInfo, color, angle, this.mirror);\r\n            }\r\n        }\r\n        else\r\n            drawTile(pos, size, this.tileInfo, color, angle, this.mirror);\r\n        this.additive && setBlendMode();\r\n        debugParticles && debugRect(pos, size, '#f005', 0, angle);\r\n\r\n        if (p == 1)\r\n        {\r\n            // destroy particle when it's time runs out\r\n            this.color = color;\r\n            this.size = size;\r\n            this.destroyCallback && this.destroyCallback(this);\r\n            this.destroyed = 1;\r\n        }\r\n    }\r\n}\n/** \r\n * LittleJS Medal System\r\n * - Tracks and displays medals\r\n * - Saves medals to local storage\r\n * - Newgrounds integration\r\n * @namespace Medals\r\n */\r\n\r\n\r\n\r\n/** List of all medals\r\n *  @type {Object}\r\n *  @memberof Medals */\r\nconst medals = {};\r\n\r\n// Engine internal variables not exposed to documentation\r\nlet medalsDisplayQueue = [], medalsSaveName, medalsDisplayTimeLast;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Initialize medals with a save name used for storage\r\n *  - Call this after creating all medals\r\n *  - Checks if medals are unlocked\r\n *  @param {String} saveName\r\n *  @memberof Medals */\r\nfunction medalsInit(saveName)\r\n{\r\n    // check if medals are unlocked\r\n    medalsSaveName = saveName;\r\n    if (!debugMedals)\r\n        medalsForEach(medal=> medal.unlocked = (localStorage[medal.storageKey()] | 0));\r\n\r\n    // engine automatically renders medals\r\n    engineAddPlugin(undefined, medalsRender);\r\n    function medalsRender()\r\n    {\r\n        if (!medalsDisplayQueue.length)\r\n            return;\r\n        \r\n        // update first medal in queue\r\n        const medal = medalsDisplayQueue[0];\r\n        const time = timeReal - medalsDisplayTimeLast;\r\n        if (!medalsDisplayTimeLast)\r\n            medalsDisplayTimeLast = timeReal;\r\n        else if (time > medalDisplayTime)\r\n        {\r\n            medalsDisplayTimeLast = 0;\r\n            medalsDisplayQueue.shift();\r\n        }\r\n        else\r\n        {\r\n            // slide on/off medals\r\n            const slideOffTime = medalDisplayTime - medalDisplaySlideTime;\r\n            const hidePercent = \r\n                time < medalDisplaySlideTime ? 1 - time / medalDisplaySlideTime :\r\n                time > slideOffTime ? (time - slideOffTime) / medalDisplaySlideTime : 0;\r\n            medal.render(hidePercent);\r\n        }\r\n    }\r\n}\r\n\r\n/** Calls a function for each medal\r\n *  @param {Function} callback\r\n *  @memberof Medals */\r\nfunction medalsForEach(callback)\r\n{ Object.values(medals).forEach(medal=>callback(medal)); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Medal - Tracks an unlockable medal \r\n * @example\r\n * // create a medal\r\n * const medal_example = new Medal(0, 'Example Medal', 'More info about the medal goes here.', '');\r\n * \r\n * // initialize medals\r\n * medalsInit('Example Game');\r\n * \r\n * // unlock the medal\r\n * medal_example.unlock();\r\n */\r\nclass Medal\r\n{\r\n    /** Create a medal object and adds it to the list of medals\r\n     *  @param {Number} id            - The unique identifier of the medal\r\n     *  @param {String} name          - Name of the medal\r\n     *  @param {String} [description] - Description of the medal\r\n     *  @param {String} [icon]        - Icon for the medal\r\n     *  @param {String} [src]         - Image location for the medal\r\n     */\r\n    constructor(id, name, description='', icon='', src)\r\n    {\r\n        ASSERT(id >= 0 && !medals[id]);\r\n\r\n        // save attributes and add to list of medals\r\n        medals[this.id = id] = this;\r\n        this.name = name;\r\n        this.description = description;\r\n        this.icon = icon;\r\n        if (src)\r\n            (this.image = new Image).src = src;\r\n    }\r\n\r\n    /** Unlocks a medal if not already unlocked */\r\n    unlock()\r\n    {\r\n        if (medalsPreventUnlock || this.unlocked)\r\n            return;\r\n\r\n        // save the medal\r\n        ASSERT(medalsSaveName, 'save name must be set');\r\n        localStorage[this.storageKey()] = this.unlocked = 1;\r\n        medalsDisplayQueue.push(this);\r\n    }\r\n\r\n    /** Render a medal\r\n     *  @param {Number} [hidePercent] - How much to slide the medal off screen\r\n     */\r\n    render(hidePercent=0)\r\n    {\r\n        const context = overlayContext;\r\n        const width = min(medalDisplaySize.x, mainCanvas.width);\r\n        const x = overlayCanvas.width - width;\r\n        const y = -medalDisplaySize.y*hidePercent;\r\n\r\n        // draw containing rect and clip to that region\r\n        context.save();\r\n        context.beginPath();\r\n        context.fillStyle = new Color(.9,.9,.9).toString();\r\n        context.strokeStyle = new Color(0,0,0).toString();\r\n        context.lineWidth = 3;\r\n        context.rect(x, y, width, medalDisplaySize.y);\r\n        context.fill();\r\n        context.stroke();\r\n        context.clip();\r\n\r\n        // draw the icon and text\r\n        this.renderIcon(vec2(x+15+medalDisplayIconSize/2, y+medalDisplaySize.y/2));\r\n        const pos = vec2(x+medalDisplayIconSize+30, y+28);\r\n        drawTextScreen(this.name, pos, 38, new Color(0,0,0), 0, undefined, 'left');\r\n        pos.y += 32;\r\n        drawTextScreen(this.description, pos, 24, new Color(0,0,0), 0, undefined, 'left');\r\n        context.restore();\r\n    }\r\n\r\n    /** Render the icon for a medal\r\n     *  @param {Vector2} pos - Screen space position\r\n     *  @param {Number} [size=medalDisplayIconSize] - Screen space size\r\n     */\r\n    renderIcon(pos, size=medalDisplayIconSize)\r\n    {\r\n        // draw the image or icon\r\n        if (this.image)\r\n            overlayContext.drawImage(this.image, pos.x-size/2, pos.y-size/2, size, size);\r\n        else\r\n            drawTextScreen(this.icon, pos, size*.7, new Color(0,0,0));\r\n    }\r\n \r\n    // Get local storage key used by the medal\r\n    storageKey() { return medalsSaveName + '_' + this.id; }\r\n}\n/**\r\n * LittleJS WebGL Interface\r\n * - All webgl used by the engine is wrapped up here\r\n * - For normal stuff you won't need to see or call anything in this file\r\n * - For advanced stuff there are helper functions to create shaders, textures, etc\r\n * - Can be disabled with glEnable to revert to 2D canvas rendering\r\n * - Batches sprite rendering on GPU for incredibly fast performance\r\n * - Sprite transform math is done in the shader where possible\r\n * - Supports shadertoy style post processing shaders\r\n * @namespace WebGL\r\n */\r\n\r\n\r\n\r\n/** The WebGL canvas which appears above the main canvas and below the overlay canvas\r\n *  @type {HTMLCanvasElement}\r\n *  @memberof WebGL */\r\nlet glCanvas;\r\n\r\n/** 2d context for glCanvas\r\n *  @type {WebGL2RenderingContext}\r\n *  @memberof WebGL */\r\nlet glContext;\r\n\r\n// WebGL internal variables not exposed to documentation\r\nlet glShader, glActiveTexture, glArrayBuffer, glGeometryBuffer, glPositionData, glColorData, glInstanceCount, glAdditive, glBatchAdditive;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// Initalize WebGL, called automatically by the engine\r\nfunction glInit()\r\n{\r\n    if (!glEnable || headlessMode) return;\r\n\r\n    // create the canvas and textures\r\n    glCanvas = document.createElement('canvas');\r\n    glContext = glCanvas.getContext('webgl2');\r\n\r\n    // some browsers are much faster without copying the gl buffer so we just overlay it instead\r\n    glOverlay && document.body.appendChild(glCanvas);\r\n\r\n    // setup vertex and fragment shaders\r\n    glShader = glCreateProgram(\r\n        '#version 300 es\\n' +     // specify GLSL ES version\r\n        'precision highp float;'+ // use highp for better accuracy\r\n        'uniform mat4 m;'+        // transform matrix\r\n        'in vec2 g;'+             // in: geometry\r\n        'in vec4 p,u,c,a;'+       // in: position/size, uvs, color, additiveColor\r\n        'in float r;'+            // in: rotation\r\n        'out vec2 v;'+            // out: uv\r\n        'out vec4 d,e;'+          // out: color, additiveColor\r\n        'void main(){'+           // shader entry point\r\n        'vec2 s=(g-.5)*p.zw;'+    // get size offset\r\n        'gl_Position=m*vec4(p.xy+s*cos(r)-vec2(-s.y,s)*sin(r),1,1);'+ // transform position\r\n        'v=mix(u.xw,u.zy,g);'+    // pass uv to fragment shader\r\n        'd=c;e=a;'+               // pass colors to fragment shader\r\n        '}'                       // end of shader\r\n        ,\r\n        '#version 300 es\\n' +     // specify GLSL ES version\r\n        'precision highp float;'+ // use highp for better accuracy\r\n        'uniform sampler2D s;'+   // texture\r\n        'in vec2 v;'+             // in: uv\r\n        'in vec4 d,e;'+           // in: color, additiveColor\r\n        'out vec4 c;'+            // out: color\r\n        'void main(){'+           // shader entry point\r\n        'c=texture(s,v)*d+e;'+    // modulate texture by color plus additive\r\n        '}'                       // end of shader\r\n    );\r\n\r\n    // init buffers\r\n    const glInstanceData = new ArrayBuffer(gl_INSTANCE_BUFFER_SIZE);\r\n    glPositionData = new Float32Array(glInstanceData);\r\n    glColorData = new Uint32Array(glInstanceData);\r\n    glArrayBuffer = glContext.createBuffer();\r\n    glGeometryBuffer = glContext.createBuffer();\r\n\r\n    // create the geometry buffer, triangle strip square\r\n    const geometry = new Float32Array([glInstanceCount=0,0,1,0,0,1,1,1]);\r\n    glContext.bindBuffer(gl_ARRAY_BUFFER, glGeometryBuffer);\r\n    glContext.bufferData(gl_ARRAY_BUFFER, geometry, gl_STATIC_DRAW);\r\n}\r\n\r\n// Setup render each frame, called automatically by engine\r\nfunction glPreRender()\r\n{\r\n    if (!glEnable || headlessMode) return;\r\n\r\n    // clear and set to same size as main canvas\r\n    glContext.viewport(0, 0, glCanvas.width=mainCanvas.width, glCanvas.height=mainCanvas.height);\r\n    glContext.clear(gl_COLOR_BUFFER_BIT);\r\n\r\n    // set up the shader\r\n    glContext.useProgram(glShader);\r\n    glContext.activeTexture(gl_TEXTURE0);\r\n    glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = textureInfos[0].glTexture);\r\n\r\n    // set vertex attributes\r\n    let offset = glAdditive = glBatchAdditive = 0;\r\n    let initVertexAttribArray = (name, type, typeSize, size)=>\r\n    {\r\n        const location = glContext.getAttribLocation(glShader, name);\r\n        const stride = typeSize && gl_INSTANCE_BYTE_STRIDE; // only if not geometry\r\n        const divisor = typeSize && 1; // only if not geometry\r\n        const normalize = typeSize==1; // only if color\r\n        glContext.enableVertexAttribArray(location);\r\n        glContext.vertexAttribPointer(location, size, type, normalize, stride, offset);\r\n        glContext.vertexAttribDivisor(location, divisor);\r\n        offset += size*typeSize;\r\n    }\r\n    glContext.bindBuffer(gl_ARRAY_BUFFER, glGeometryBuffer);\r\n    initVertexAttribArray('g', gl_FLOAT, 0, 2); // geometry\r\n    glContext.bindBuffer(gl_ARRAY_BUFFER, glArrayBuffer);\r\n    glContext.bufferData(gl_ARRAY_BUFFER, gl_INSTANCE_BUFFER_SIZE, gl_DYNAMIC_DRAW);\r\n    initVertexAttribArray('p', gl_FLOAT, 4, 4); // position & size\r\n    initVertexAttribArray('u', gl_FLOAT, 4, 4); // texture coords\r\n    initVertexAttribArray('c', gl_UNSIGNED_BYTE, 1, 4); // color\r\n    initVertexAttribArray('a', gl_UNSIGNED_BYTE, 1, 4); // additiveColor\r\n    initVertexAttribArray('r', gl_FLOAT, 4, 1); // rotation\r\n\r\n    // build the transform matrix\r\n    const s = vec2(2*cameraScale).divide(mainCanvasSize);\r\n    const p = vec2(-1).subtract(cameraPos.multiply(s));\r\n    glContext.uniformMatrix4fv(glContext.getUniformLocation(glShader, 'm'), false,\r\n        [\r\n            s.x, 0,   0,   0,\r\n            0,   s.y, 0,   0,\r\n            1,   1,   1,   1,\r\n            p.x, p.y, 0,   0\r\n        ]\r\n    );\r\n}\r\n\r\n/** Set the WebGl texture, called automatically if using multiple textures\r\n *  - This may also flush the gl buffer resulting in more draw calls and worse performance\r\n *  @param {WebGLTexture} texture\r\n *  @memberof WebGL */\r\nfunction glSetTexture(texture)\r\n{\r\n    // must flush cache with the old texture to set a new one\r\n    if (headlessMode || texture == glActiveTexture)\r\n        return;\r\n\r\n    glFlush();\r\n    glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = texture);\r\n}\r\n\r\n/** Compile WebGL shader of the given type, will throw errors if in debug mode\r\n *  @param {String} source\r\n *  @param {Number} type\r\n *  @return {WebGLShader}\r\n *  @memberof WebGL */\r\nfunction glCompileShader(source, type)\r\n{\r\n    // build the shader\r\n    const shader = glContext.createShader(type);\r\n    glContext.shaderSource(shader, source);\r\n    glContext.compileShader(shader);\r\n\r\n    // check for errors\r\n    if (debug && !glContext.getShaderParameter(shader, gl_COMPILE_STATUS))\r\n        throw glContext.getShaderInfoLog(shader);\r\n    return shader;\r\n}\r\n\r\n/** Create WebGL program with given shaders\r\n *  @param {String} vsSource\r\n *  @param {String} fsSource\r\n *  @return {WebGLProgram}\r\n *  @memberof WebGL */\r\nfunction glCreateProgram(vsSource, fsSource)\r\n{\r\n    // build the program\r\n    const program = glContext.createProgram();\r\n    glContext.attachShader(program, glCompileShader(vsSource, gl_VERTEX_SHADER));\r\n    glContext.attachShader(program, glCompileShader(fsSource, gl_FRAGMENT_SHADER));\r\n    glContext.linkProgram(program);\r\n\r\n    // check for errors\r\n    if (debug && !glContext.getProgramParameter(program, gl_LINK_STATUS))\r\n        throw glContext.getProgramInfoLog(program);\r\n    return program;\r\n}\r\n\r\n/** Create WebGL texture from an image and init the texture settings\r\n *  @param {HTMLImageElement} image\r\n *  @return {WebGLTexture}\r\n *  @memberof WebGL */\r\nfunction glCreateTexture(image)\r\n{\r\n    // build the texture\r\n    const texture = glContext.createTexture();\r\n    glContext.bindTexture(gl_TEXTURE_2D, texture);\r\n    if (image)\r\n        glContext.texImage2D(gl_TEXTURE_2D, 0, gl_RGBA, gl_RGBA, gl_UNSIGNED_BYTE, image);\r\n\r\n    // use point filtering for pixelated rendering\r\n    const filter = canvasPixelated ? gl_NEAREST : gl_LINEAR;\r\n    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MIN_FILTER, filter);\r\n    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MAG_FILTER, filter);\r\n    return texture;\r\n}\r\n\r\n/** Draw all sprites and clear out the buffer, called automatically by the system whenever necessary\r\n *  @memberof WebGL */\r\nfunction glFlush()\r\n{\r\n    if (!glInstanceCount) return;\r\n\r\n    const destBlend = glBatchAdditive ? gl_ONE : gl_ONE_MINUS_SRC_ALPHA;\r\n    glContext.blendFuncSeparate(gl_SRC_ALPHA, destBlend, gl_ONE, destBlend);\r\n    glContext.enable(gl_BLEND);\r\n\r\n    // draw all the sprites in the batch and reset the buffer\r\n    glContext.bufferSubData(gl_ARRAY_BUFFER, 0, glPositionData);\r\n    glContext.drawArraysInstanced(gl_TRIANGLE_STRIP, 0, 4, glInstanceCount);\r\n    if (showWatermark)\r\n        drawCount += glInstanceCount;\r\n    glInstanceCount = 0;\r\n    glBatchAdditive = glAdditive;\r\n}\r\n\r\n/** Draw any sprites still in the buffer, copy to main canvas and clear\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context\r\n *  @param {Boolean} [forceDraw]\r\n *  @memberof WebGL */\r\nfunction glCopyToContext(context, forceDraw=false)\r\n{\r\n    if (!glEnable || !glInstanceCount && !forceDraw) return;\r\n\r\n    glFlush();\r\n\r\n    // do not draw in overlay mode because the canvas is visible\r\n    if (!glOverlay || forceDraw)\r\n        context.drawImage(glCanvas, 0, 0);\r\n}\r\n\r\n/** Add a sprite to the gl draw list, used by all gl draw functions\r\n *  @param {Number} x\r\n *  @param {Number} y\r\n *  @param {Number} sizeX\r\n *  @param {Number} sizeY\r\n *  @param {Number} angle\r\n *  @param {Number} uv0X\r\n *  @param {Number} uv0Y\r\n *  @param {Number} uv1X\r\n *  @param {Number} uv1Y\r\n *  @param {Number} rgba\r\n *  @param {Number} [rgbaAdditive=0]\r\n *  @memberof WebGL */\r\nfunction glDraw(x, y, sizeX, sizeY, angle, uv0X, uv0Y, uv1X, uv1Y, rgba, rgbaAdditive=0)\r\n{\r\n    ASSERT(typeof rgba == 'number' && typeof rgbaAdditive == 'number', 'invalid color');\r\n\r\n    // flush if there is not enough room or if different blend mode\r\n    if (glInstanceCount >= gl_MAX_INSTANCES || glBatchAdditive != glAdditive)\r\n        glFlush();\r\n\r\n    let offset = glInstanceCount * gl_INDICIES_PER_INSTANCE;\r\n    glPositionData[offset++] = x;\r\n    glPositionData[offset++] = y;\r\n    glPositionData[offset++] = sizeX;\r\n    glPositionData[offset++] = sizeY;\r\n    glPositionData[offset++] = uv0X;\r\n    glPositionData[offset++] = uv0Y;\r\n    glPositionData[offset++] = uv1X;\r\n    glPositionData[offset++] = uv1Y;\r\n    glColorData[offset++] = rgba;\r\n    glColorData[offset++] = rgbaAdditive;\r\n    glPositionData[offset++] = angle;\r\n    glInstanceCount++;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// store gl constants as integers so their name doesn't use space in minifed\r\nconst\r\ngl_ONE = 1,\r\ngl_TRIANGLE_STRIP = 5,\r\ngl_SRC_ALPHA = 770,\r\ngl_ONE_MINUS_SRC_ALPHA = 771,\r\ngl_BLEND = 3042,\r\ngl_TEXTURE_2D = 3553,\r\ngl_UNSIGNED_BYTE = 5121,\r\ngl_FLOAT = 5126,\r\ngl_RGBA = 6408,\r\ngl_NEAREST = 9728,\r\ngl_LINEAR = 9729,\r\ngl_TEXTURE_MAG_FILTER = 10240,\r\ngl_TEXTURE_MIN_FILTER = 10241,\r\ngl_COLOR_BUFFER_BIT = 16384,\r\ngl_TEXTURE0 = 33984,\r\ngl_ARRAY_BUFFER = 34962,\r\ngl_STATIC_DRAW = 35044,\r\ngl_DYNAMIC_DRAW = 35048,\r\ngl_FRAGMENT_SHADER = 35632,\r\ngl_VERTEX_SHADER = 35633,\r\ngl_COMPILE_STATUS = 35713,\r\ngl_LINK_STATUS = 35714,\r\ngl_UNPACK_FLIP_Y_WEBGL = 37440,\r\n\r\n// constants for batch rendering\r\ngl_INDICIES_PER_INSTANCE = 11,\r\ngl_MAX_INSTANCES = 1e4,\r\ngl_INSTANCE_BYTE_STRIDE = gl_INDICIES_PER_INSTANCE * 4, // 11 * 4\r\ngl_INSTANCE_BUFFER_SIZE = gl_MAX_INSTANCES * gl_INSTANCE_BYTE_STRIDE;\n/** \r\n * LittleJS - The Tiny Fast JavaScript Game Engine\r\n * MIT License - Copyright 2021 Frank Force\r\n * \r\n * Engine Features\r\n * - Object oriented system with base class engine object\r\n * - Base class object handles update, physics, collision, rendering, etc\r\n * - Engine helper classes and functions like Vector2, Color, and Timer\r\n * - Super fast rendering system for tile sheets\r\n * - Sound effects audio with zzfx and music with zzfxm\r\n * - Input processing system with gamepad and touchscreen support\r\n * - Tile layer rendering and collision system\r\n * - Particle effect system\r\n * - Medal system tracks and displays achievements\r\n * - Debug tools and debug rendering system\r\n * - Post processing effects\r\n * - Call engineInit() to start it up!\r\n * @namespace Engine\r\n */\r\n\r\n\r\n\r\n/** Name of engine\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Engine */\r\nconst engineName = 'LittleJS';\r\n\r\n/** Version of engine\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Engine */\r\nconst engineVersion = '1.9.11';\r\n\r\n/** Frames per second to update\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Engine */\r\nconst frameRate = 60;\r\n\r\n/** How many seconds each frame lasts, engine uses a fixed time step\r\n *  @type {Number}\r\n *  @default 1/60\r\n *  @memberof Engine */\r\nconst timeDelta = 1/frameRate;\r\n\r\n/** Array containing all engine objects\r\n *  @type {Array}\r\n *  @memberof Engine */\r\nlet engineObjects = [];\r\n\r\n/** Array with only objects set to collide with other objects this frame (for optimization)\r\n *  @type {Array}\r\n *  @memberof Engine */\r\nlet engineObjectsCollide = [];\r\n\r\n/** Current update frame, used to calculate time\r\n *  @type {Number}\r\n *  @memberof Engine */\r\nlet frame = 0;\r\n\r\n/** Current engine time since start in seconds\r\n *  @type {Number}\r\n *  @memberof Engine */\r\nlet time = 0;\r\n\r\n/** Actual clock time since start in seconds (not affected by pause or frame rate clamping)\r\n *  @type {Number}\r\n *  @memberof Engine */\r\nlet timeReal = 0;\r\n\r\n/** Is the game paused? Causes time and objects to not be updated\r\n *  @type {Boolean}\r\n *  @default false\r\n *  @memberof Engine */\r\nlet paused = false;\r\n\r\n/** Set if game is paused\r\n *  @param {Boolean} isPaused\r\n *  @memberof Engine */\r\nfunction setPaused(isPaused) { paused = isPaused; }\r\n\r\n// Frame time tracking\r\nlet frameTimeLastMS = 0, frameTimeBufferMS = 0, averageFPS = 0;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// plugin hooks\r\n\r\nconst pluginUpdateList = [], pluginRenderList = [];\r\n\r\n/** Add a new update function for a plugin\r\n *  @param {Function} [updateFunction]\r\n *  @param {Function} [renderFunction]\r\n *  @memberof Engine */\r\nfunction engineAddPlugin(updateFunction, renderFunction)\r\n{\r\n    updateFunction && pluginUpdateList.push(updateFunction);\r\n    renderFunction && pluginRenderList.push(renderFunction);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Main engine functions\r\n\r\n/** Startup LittleJS engine with your callback functions\r\n *  @param {Function} gameInit       - Called once after the engine starts up, setup the game\r\n *  @param {Function} gameUpdate     - Called every frame at 60 frames per second, handle input and update the game state\r\n *  @param {Function} gameUpdatePost - Called after physics and objects are updated, setup camera and prepare for render\r\n *  @param {Function} gameRender     - Called before objects are rendered, draw any background effects that appear behind objects\r\n *  @param {Function} gameRenderPost - Called after objects are rendered, draw effects or hud that appear above all objects\r\n *  @param {Array} [imageSources=['tiles.png']] - Image to load\r\n *  @memberof Engine */\r\nfunction engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost, imageSources=['tiles.png'])\r\n{\r\n    ASSERT(Array.isArray(imageSources), 'pass in images as array');\r\n\r\n    // Called automatically by engine to setup render system\r\n    function enginePreRender()\r\n    {\r\n        // save canvas size\r\n        mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);\r\n\r\n        // disable smoothing for pixel art\r\n        mainContext.imageSmoothingEnabled = !canvasPixelated;\r\n\r\n        // setup gl rendering if enabled\r\n        glPreRender();\r\n    }\r\n\r\n    // internal update loop for engine\r\n    function engineUpdate(frameTimeMS=0)\r\n    {\r\n        // update time keeping\r\n        let frameTimeDeltaMS = frameTimeMS - frameTimeLastMS;\r\n        frameTimeLastMS = frameTimeMS;\r\n        if (debug || showWatermark)\r\n            averageFPS = lerp(.05, averageFPS, 1e3/(frameTimeDeltaMS||1));\r\n        const debugSpeedUp   = debug && keyIsDown('Equal'); // +\r\n        const debugSpeedDown = debug && keyIsDown('Minus'); // -\r\n        if (debug) // +/- to speed/slow time\r\n            frameTimeDeltaMS *= debugSpeedUp ? 5 : debugSpeedDown ? .2 : 1;\r\n        timeReal += frameTimeDeltaMS / 1e3;\r\n        frameTimeBufferMS += paused ? 0 : frameTimeDeltaMS;\r\n        if (!debugSpeedUp)\r\n            frameTimeBufferMS = min(frameTimeBufferMS, 50); // clamp in case of slow framerate\r\n\r\n        updateCanvas();\r\n\r\n        if (paused)\r\n        {\r\n            // update object transforms even when paused\r\n            for (const o of engineObjects)\r\n                o.parent || o.updateTransforms();\r\n            inputUpdate();\r\n            debugUpdate();\r\n            gameUpdatePost();\r\n            inputUpdatePost();\r\n        }\r\n        else\r\n        {\r\n            // apply time delta smoothing, improves smoothness of framerate in some browsers\r\n            let deltaSmooth = 0;\r\n            if (frameTimeBufferMS < 0 && frameTimeBufferMS > -9)\r\n            {\r\n                // force at least one update each frame since it is waiting for refresh\r\n                deltaSmooth = frameTimeBufferMS;\r\n                frameTimeBufferMS = 0;\r\n            }\r\n            \r\n            // update multiple frames if necessary in case of slow framerate\r\n            for (;frameTimeBufferMS >= 0; frameTimeBufferMS -= 1e3 / frameRate)\r\n            {\r\n                // increment frame and update time\r\n                time = frame++ / frameRate;\r\n\r\n                // update game and objects\r\n                inputUpdate();\r\n                gameUpdate();\r\n                pluginUpdateList.forEach(f=>f());\r\n                engineObjectsUpdate();\r\n\r\n                // do post update\r\n                debugUpdate();\r\n                gameUpdatePost();\r\n                inputUpdatePost();\r\n            }\r\n\r\n            // add the time smoothing back in\r\n            frameTimeBufferMS += deltaSmooth;\r\n        }\r\n\r\n        if (!headlessMode)\r\n        {\r\n            // render sort then render while removing destroyed objects\r\n            enginePreRender();\r\n            gameRender();\r\n            engineObjects.sort((a,b)=> a.renderOrder - b.renderOrder);\r\n            for (const o of engineObjects)\r\n                o.destroyed || o.render();\r\n            gameRenderPost();\r\n            pluginRenderList.forEach(f=>f());\r\n            touchGamepadRender();\r\n            debugRender();\r\n            glCopyToContext(mainContext);\r\n\r\n            if (showWatermark)\r\n            {\r\n                // update fps\r\n                overlayContext.textAlign = 'right';\r\n                overlayContext.textBaseline = 'top';\r\n                overlayContext.font = '1em monospace';\r\n                overlayContext.fillStyle = '#000';\r\n                const text = engineName + ' ' + 'v' + engineVersion + ' / ' \r\n                    + drawCount + ' / ' + engineObjects.length + ' / ' + averageFPS.toFixed(1)\r\n                    + (glEnable ? ' GL' : ' 2D') ;\r\n                overlayContext.fillText(text, mainCanvas.width-3, 3);\r\n                overlayContext.fillStyle = '#fff';\r\n                overlayContext.fillText(text, mainCanvas.width-2, 2);\r\n                drawCount = 0;\r\n            }\r\n        }\r\n\r\n        requestAnimationFrame(engineUpdate);\r\n    }\r\n\r\n    function updateCanvas()\r\n    {\r\n        if (headlessMode) return;\r\n        \r\n        if (canvasFixedSize.x)\r\n        {\r\n            // clear canvas and set fixed size\r\n            mainCanvas.width  = canvasFixedSize.x;\r\n            mainCanvas.height = canvasFixedSize.y;\r\n            \r\n            // fit to window by adding space on top or bottom if necessary\r\n            const aspect = innerWidth / innerHeight;\r\n            const fixedAspect = mainCanvas.width / mainCanvas.height;\r\n            (glCanvas||mainCanvas).style.width = mainCanvas.style.width = overlayCanvas.style.width  = aspect < fixedAspect ? '100%' : '';\r\n            (glCanvas||mainCanvas).style.height = mainCanvas.style.height = overlayCanvas.style.height = aspect < fixedAspect ? '' : '100%';\r\n        }\r\n        else\r\n        {\r\n            // clear canvas and set size to same as window\r\n            mainCanvas.width  = min(innerWidth,  canvasMaxSize.x);\r\n            mainCanvas.height = min(innerHeight, canvasMaxSize.y);\r\n        }\r\n        \r\n        // clear overlay canvas and set size\r\n        overlayCanvas.width  = mainCanvas.width;\r\n        overlayCanvas.height = mainCanvas.height;\r\n\r\n        // save canvas size\r\n        mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);\r\n    }\r\n\r\n    function startEngine()\r\n    {\r\n        gameInit();\r\n        engineUpdate();\r\n    }\r\n\r\n    if (headlessMode)\r\n    {\r\n        startEngine();\r\n        return;\r\n    }\r\n\r\n    // setup html\r\n    const styleBody = \r\n        'margin:0;overflow:hidden;' + // fill the window\r\n        'background:#000;' +          // set background color\r\n        'user-select:none;' +         // prevent hold to select\r\n        '-webkit-user-select:none;' + // compatibility for ios\r\n        (!touchInputEnable ? '' :     // no touch css setttings\r\n        'touch-action:none;' +        // prevent mobile pinch to resize\r\n        '-webkit-touch-callout:none');// compatibility for ios\r\n    document.body.style.cssText = styleBody;\r\n    document.body.appendChild(mainCanvas = document.createElement('canvas'));\r\n    mainContext = mainCanvas.getContext('2d');\r\n\r\n    // init stuff and start engine\r\n    inputInit();\r\n    audioInit();\r\n    debugInit();\r\n    glInit();\r\n\r\n    // create overlay canvas for hud to appear above gl canvas\r\n    document.body.appendChild(overlayCanvas = document.createElement('canvas'));\r\n    overlayContext = overlayCanvas.getContext('2d');\r\n\r\n    // set canvas style\r\n    const styleCanvas = 'position:absolute;' +             // position\r\n        'top:50%;left:50%;transform:translate(-50%,-50%)'; // center\r\n    (glCanvas||mainCanvas).style.cssText = mainCanvas.style.cssText = overlayCanvas.style.cssText = styleCanvas;\r\n    updateCanvas();\r\n    \r\n    // create promises for loading images\r\n    const promises = imageSources.map((src, textureIndex)=>\r\n        new Promise(resolve => \r\n        {\r\n            const image = new Image;\r\n            image.onerror = image.onload = ()=> \r\n            {\r\n                textureInfos[textureIndex] = new TextureInfo(image);\r\n                resolve();\r\n            }\r\n            image.src = src;\r\n        })\r\n    );\r\n\r\n    // draw splash screen\r\n    showSplashScreen && promises.push(new Promise(resolve => \r\n    {\r\n        let t = 0;\r\n        console.log(`${engineName} Engine v${engineVersion}`);\r\n        updateSplash();\r\n        function updateSplash()\r\n        {\r\n            clearInput();\r\n            drawEngineSplashScreen(t+=.01);\r\n            t>1 ? resolve() : setTimeout(updateSplash, 16);\r\n        }\r\n    }));\r\n\r\n    // load all of the images\r\n    Promise.all(promises).then(startEngine);\r\n}\r\n\r\n/** Update each engine object, remove destroyed objects, and update time\r\n *  @memberof Engine */\r\nfunction engineObjectsUpdate()\r\n{\r\n    // get list of solid objects for physics optimzation\r\n    engineObjectsCollide = engineObjects.filter(o=>o.collideSolidObjects);\r\n\r\n    // recursive object update\r\n    function updateObject(o)\r\n    {\r\n        if (!o.destroyed)\r\n        {\r\n            o.update();\r\n            for (const child of o.children)\r\n                updateObject(child);\r\n        }\r\n    }\r\n    for (const o of engineObjects)\r\n    {\r\n        // update top level objects\r\n        if (!o.parent)\r\n        {\r\n            updateObject(o);\r\n            o.updateTransforms();\r\n        }\r\n    }\r\n\r\n    // remove destroyed objects\r\n    engineObjects = engineObjects.filter(o=>!o.destroyed);\r\n}\r\n\r\n/** Destroy and remove all objects\r\n *  @memberof Engine */\r\nfunction engineObjectsDestroy()\r\n{\r\n    for (const o of engineObjects)\r\n        o.parent || o.destroy();\r\n    engineObjects = engineObjects.filter(o=>!o.destroyed);\r\n}\r\n\r\n/** Collects all object within a given area\r\n *  @param {Vector2} [pos]                 - Center of test area, or undefined for all objects\r\n *  @param {Number|Vector2} [size]         - Radius of circle if float, rectangle size if Vector2\r\n *  @param {Array} [objects=engineObjects] - List of objects to check\r\n *  @return {Array}                        - List of collected objects\r\n *  @memberof Engine */\r\nfunction engineObjectsCollect(pos, size, objects=engineObjects)\r\n{\r\n    const collectedObjects = [];\r\n    if (!pos) // all objects\r\n    {\r\n        for (const o of objects)\r\n            collectedObjects.push(o);\r\n    }\r\n    else if (size instanceof Vector2)  // bounding box test\r\n    {\r\n        for (const o of objects)\r\n            isOverlapping(pos, size, o.pos, o.size) && collectedObjects.push(o);\r\n    }\r\n    else  // circle test\r\n    {\r\n        const sizeSquared = size*size;\r\n        for (const o of objects)\r\n            pos.distanceSquared(o.pos) < sizeSquared && collectedObjects.push(o);\r\n    }\r\n    return collectedObjects;\r\n}\r\n\r\n/** Triggers a callback for each object within a given area\r\n *  @param {Vector2} [pos]                 - Center of test area, or undefined for all objects\r\n *  @param {Number|Vector2} [size]         - Radius of circle if float, rectangle size if Vector2\r\n *  @param {Function} [callbackFunction]   - Calls this function on every object that passes the test\r\n *  @param {Array} [objects=engineObjects] - List of objects to check\r\n *  @memberof Engine */\r\nfunction engineObjectsCallback(pos, size, callbackFunction, objects=engineObjects)\r\n{ engineObjectsCollect(pos, size, objects).forEach(o => callbackFunction(o)); }\r\n\r\n/** Return a list of objects intersecting a ray\r\n *  @param {Vector2} start\r\n *  @param {Vector2} end\r\n *  @param {Array} [objects=engineObjects] - List of objects to check\r\n *  @return {Array} - List of objects hit\r\n *  @memberof Engine */\r\nfunction engineObjectsRaycast(start, end, objects=engineObjects)\r\n{\r\n    const hitObjects = [];\r\n    for (const o of objects)\r\n    {\r\n        if (o.collideRaycast && isIntersecting(start, end, o.pos, o.size))\r\n        {\r\n            debugRaycast && debugRect(o.pos, o.size, '#f00');\r\n            hitObjects.push(o);\r\n        }\r\n    }\r\n\r\n    debugRaycast && debugLine(start, end, hitObjects.length ? '#f00' : '#00f', .02);\r\n    return hitObjects;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// LittleJS splash screen and logo\r\n\r\nfunction drawEngineSplashScreen(t)\r\n{\r\n    const x = overlayContext;\r\n    const w = overlayCanvas.width = innerWidth;\r\n    const h = overlayCanvas.height = innerHeight;\r\n\r\n    {\r\n        // background\r\n        const p3 = percent(t, 1, .8);\r\n        const p4 = percent(t, 0, .5);\r\n        const g = x.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.hypot(w,h)*.7);\r\n        g.addColorStop(0,hsl(0,0,lerp(p4,0,p3/2),p3).toString());\r\n        g.addColorStop(1,hsl(0,0,0,p3).toString());\r\n        x.save();\r\n        x.fillStyle = g;\r\n        x.fillRect(0,0,w,h);\r\n    }\r\n\r\n    // draw LittleJS logo...\r\n    const rect = (X, Y, W, H, C)=>\r\n    {\r\n        x.beginPath();\r\n        x.rect(X,Y,W,C?H*p:H);\r\n        x.fillStyle = C;\r\n        C ? x.fill() : x.stroke();\r\n    };\r\n    const line = (X, Y, Z, W)=>\r\n    {\r\n        x.beginPath();\r\n        x.lineTo(X,Y);\r\n        x.lineTo(Z,W);\r\n        x.stroke();\r\n    };\r\n    const circle = (X, Y, R, A=0, B=2*PI, C, F)=>\r\n    {\r\n        const D = (A+B)/2, E = p*(B-A)/2;\r\n        x.beginPath();\r\n        F && x.lineTo(X,Y);\r\n        x.arc(X,Y,R,D-E,D+E);\r\n        x.fillStyle = C;\r\n        C ? x.fill() : x.stroke();\r\n    };\r\n    const color = (c=0, l=0) =>\r\n        hsl([.98,.3,.57,.14][c%4]-10,.8,[0,.3,.5,.8,.9][l]).toString();\r\n    const alpha = wave(1,1,t);\r\n    const p = percent(alpha, .1, .5);\r\n\r\n    // setup\r\n    x.translate(w/2,h/2);\r\n    const size = min(6, min(w,h)/99); // fit to screen\r\n    x.scale(size,size);\r\n    x.translate(-40,-35);\r\n    x.lineJoin = x.lineCap = 'round';\r\n    x.lineWidth = .1 + p*1.9;\r\n\r\n    // drawing effect\r\n    const p2 = percent(alpha,.1,1);\r\n    x.setLineDash([99*p2,99]);\r\n\r\n    // cab top\r\n    rect(7,16,18,-8,color(2,2));\r\n    rect(7,8,18,4,color(2,3));\r\n    rect(25,8,8,8,color(2,1));\r\n    rect(25,8,-18,8);\r\n    rect(25,8,8,8);\r\n\r\n    // cab\r\n    rect(25,16,7,23,color());\r\n    rect(11,39,14,-23,color(1,1));\r\n    rect(11,16,14,18,color(1,2));\r\n    rect(11,16,14,8,color(1,3));\r\n    rect(25,16,-14,24);\r\n\r\n    // cab window\r\n    rect(15,29,6,-9,color(2,2));\r\n    circle(15,21,5,0,PI/2,color(2,4),1);\r\n    rect(21,21,-6,9);\r\n\r\n    // little stack\r\n    rect(37,14,9,6,color(3,2));\r\n    rect(37,14,4.5,6,color(3,3));\r\n    rect(37,14,9,6);\r\n\r\n    // big stack\r\n    rect(50,20,10,-8,color(0,1));\r\n    rect(50,20,6.5,-8,color(0,2));\r\n    rect(50,20,3.5,-8,color(0,3));\r\n    rect(50,20,10,-8);\r\n    circle(55,2,11.4,.5,PI-.5,color(3,3));\r\n    circle(55,2,11.4,.5,PI/2,color(3,2),1);\r\n    circle(55,2,11.4,.5,PI-.5);\r\n    rect(45,7,20,-7,color(0,2));\r\n    rect(45,-1,20,4,color(0,3));\r\n    rect(45,-1,20,8);\r\n\r\n    // engine\r\n    for (let i=5; i--;)\r\n    {\r\n        // stagger radius to fix slight seam\r\n        circle(60-i*6,30, 9.9,0,2*PI,color(i+2,3));\r\n        circle(60-i*6,30,10.0,-.5,PI+.5,color(i+2,2));\r\n        circle(60-i*6,30,10.1,.5,PI-.5,color(i+2,1));\r\n    }\r\n\r\n    // engine outline\r\n    circle(36,30,10,PI/2,PI*3/2);\r\n    circle(48,30,10,PI/2,PI*3/2);\r\n    circle(60,30,10);\r\n    line(36,20,60,20);\r\n\r\n    // engine front light\r\n    circle(60,30,4,PI,3*PI,color(3,2)); \r\n    circle(60,30,4,PI,2*PI,color(3,3));\r\n    circle(60,30,4,PI,3*PI);\r\n\r\n    // front brush\r\n    for (let i=6; i--;)\r\n    {\r\n        x.beginPath();\r\n        x.lineTo(53,54);\r\n        x.lineTo(53,40);\r\n        x.lineTo(53+(1+i*2.9)*p,40);\r\n        x.lineTo(53+(4+i*3.5)*p,54);\r\n        x.fillStyle = color(0,i%2+2);\r\n        x.fill();\r\n        i%2 && x.stroke();\r\n    }\r\n\r\n    // wheels\r\n    rect(6,40,5,5);\r\n    rect(6,40,5,5,color());\r\n    rect(15,54,38,-14,color());\r\n    for (let i=3; i--;)\r\n    for (let j=2; j--;)\r\n    {\r\n        circle(15*i+15,47,j?7:1,PI,3*PI,color(i,3));\r\n        x.stroke();\r\n        circle(15*i+15,47,j?7:1,0,PI,color(i,2));\r\n        x.stroke();\r\n    }\r\n    line(6,40,68,40); // center\r\n    line(77,54,4,54); // bottom\r\n\r\n    // draw engine name\r\n    const s = engineName;\r\n    x.font = '900 16px arial';\r\n    x.textAlign = 'center';\r\n    x.textBaseline = 'top';\r\n    x.lineWidth = .1+p*3.9;\r\n    let w2 = 0;\r\n    for (let i=0; i<s.length; ++i)\r\n        w2 += x.measureText(s[i]).width;\r\n    for (let j=2; j--;)\r\n    for (let i=0, X=41-w2/2; i<s.length; ++i)\r\n    {\r\n        x.fillStyle = color(i,2);\r\n        const w = x.measureText(s[i]).width;\r\n        x[j?'strokeText':'fillText'](s[i],X+w/2,55.5,17*p);\r\n        X += w;\r\n    }\r\n    \r\n    x.restore();\r\n}\n\n/** \r\n * LittleJS Module Export\r\n * - Export engine as a module\r\n */\r\n\r\n\r\n\n\n\n//# sourceURL=webpack://wanderpaw/./node_modules/littlejsengine/dist/littlejs.esm.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var littlejsengine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! littlejsengine */ \"./node_modules/littlejsengine/dist/littlejs.esm.js\");\n/* harmony import */ var _images_tiles_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./images/tiles.png */ \"./src/images/tiles.png\");\n\n\n\nfunction gameInit()\n{\n    // called once after the engine starts up\n    // setup the game\n}\n\n///////////////////////////////////////////////////////////////////////////////\nfunction gameUpdate()\n{\n    // called every frame at 60 frames per second\n    // handle input and update the game state\n}\n\n///////////////////////////////////////////////////////////////////////////////\nfunction gameUpdatePost()\n{\n    // called after physics and objects are updated\n    // setup camera and prepare for render\n}\n\n///////////////////////////////////////////////////////////////////////////////\nfunction gameRender()\n{\n    // called before objects are rendered\n    // draw any background effects that appear behind objects\n}\n\n///////////////////////////////////////////////////////////////////////////////\nfunction gameRenderPost()\n{\n    // called after objects are rendered\n    // draw effects or hud that appear above all objects\n    littlejsengine__WEBPACK_IMPORTED_MODULE_0__.drawTextScreen('Hello World!', littlejsengine__WEBPACK_IMPORTED_MODULE_0__.mainCanvasSize.scale(.5), 80);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Startup LittleJS Engine\nlittlejsengine__WEBPACK_IMPORTED_MODULE_0__.engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);\n\n//# sourceURL=webpack://wanderpaw/./src/game.js?");

/***/ }),

/***/ "./src/images/tiles.png":
/*!******************************!*\
  !*** ./src/images/tiles.png ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"69a279a40662f346633d.png\";\n\n//# sourceURL=webpack://wanderpaw/./src/images/tiles.png?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/game.js");
/******/ 	
/******/ })()
;